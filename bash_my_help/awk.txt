gawk [ POSIX or GNU style options ] -f program-file [ -- ] file ... 
gawk [ POSIX or GNU style options ] [ -- ] program-text file ...


Командная строка состоит из опций gawk, текста программы AWK (если не были указаны опции -f или --file) и значений, которые в дальнейшем будут присвоены встроенным переменным AWK ARGC и ARGV.  
Сначала gawk читает исходный текст программы из файлов-с-программой и из аргументов опции --source, если они указаны, или из первого аргумента командной строки, не являющегося опцией. Опции -f и --source могут быть указаны в командной строке несколько раз.
Переменная окружения AWKPATH содержит путь, по которому производится поиск файлов, указанных в качестве аргумента опции -f. Если эта переменная не указана, то, по умолчанию, используется путь ".:/usr/local/share/awk".
Gawk выполняет программы следующим образом. Сперва производится инициализация переменных, указанных опцией -v. Далее gawk компилирует программу во внутренний формат. Затем gawk исполняет код в блоке (блоках) BEGIN, если таковые имеются, и начинает читать файлы, имена которых содержатся в массиве ARGV. Если в командной строке не были указаны файлы, то gawk читает стандартный поток ввода. 
Если имя файла в командной строке имеет вид переменная=значение, то оно воспринимается как операция присваивания. Переменной присваивается значение. (Это происходит после выполнения блока (блоков) BEGIN.)

Записи
По умолчанию записи разделяются символами новой строки. Вы можете переопределить способ разделения записей, присвоив нужное значение встроенной переменной RS. Если значение RS - единственный символ, то он будет использоваться для разделения записей. В противном случае RS - регулярное выражение. Текст входного потока, совпавший с ним, будет разделять записи. В режиме совместимости для разделения записей будет использоваться только первый символ строки выражения. Если RS - пустая строка, то записи будут разделяться пустыми строками. При этом символ новой строки всегда будет работать как разделитель полей, в дополнение к значению FS.  

Поля
Каждую считываемую строку gawk разбивает на поля, используя значение переменной FS в качестве разделителя. Если значение FS - единственный символ, то поля разделяются этим символом. Если значение FS - пустая строка, то каждый символ считается отдельным полем. В противном случае, FS считается регулярным выражением. Исключение составляет случай, когда значение FS - один пробел.
 Если переменная FIELDWIDTHS содержит список чисел, разделенных пробелами, то gawk считает ширину каждого поля фиксированной и разделяет запись в соответствие c указанными значениями. Значение переменной FS в этом случае игнорируется. Присваивание нового значения переменной FS аннулирует использование FIELDWIDTHS и восстанавливает поведение, принятое по умолчанию.
На любое поле входной записи можно ссылаться по его позиции - $1, $2 и так далее. $0 ссылается на всю запись. Кроме того, любому полю можно присвоить значение. Для ссылок на поля необязательно использовать константы.
    n = 5
    print $n 



Встроенными переменными Gawk являются:
ARGC
    Количество аргументов командной строки (исключая опции gawk и исходный текст программы). 
ARGIND
    Индекс массива ARGV, указывающий на обрабатываемый в данный момент файл. 
ARGV
    Массив аргументов командной строки. Индекс массива может принимать значения от 0 до ARGC - 1. Изменяя в процессе работы программы содержимое ARGV, можно контролировать, какие файлы обрабатываются. 
CONVFMT
    Формат преобразования чисел. По умолчанию "%.6g". 
ENVIRON
    Массив текущих значений переменных окружения. Массив индексирован по названиям переменных, каждый элемент содержит значение соответствующей переменной (например, ENVIRON["HOME"] может иметь значение /home/arnold). Изменение содержимого этого массива не влияет на значения переменных окружения, видимых программами, запускаемыми из gawk с помощью функции system(). (Возможно, в следующих версиях gawk это изменится.) 
ERRNO
    Если происходит системная ошибка при перенаправлении для getline, при чтении для getline, или при вызове close(), то ERRNO будет содержать строку, которая описывает ошибку. 
FIELDWIDTHS
    Список длин полей, разделенный пробелами. Если этой переменной присваивается новое значение, то gawk разделяет входные данные на поля фиксированной длины, при этом значение переменной FS игнорируется. Возможность работы с полями фиксированной длины все еще находится в стадии проверки; семантика может поменяться в процессе развития gawk. 
FILENAME
    Имя файла, обрабатываемого в данный момент. Если в командной строке не было указано ни одного файла, то значение FILENAME равно ``-''. В блоке BEGIN переменная FILENAME не определена. 
FNR
    Номер входной записи в текущем входном файле. 
FS
    Разделитель полей во входном потоке, по умолчанию пробел. Обращайтесь к подразделу Поля выше. 
IGNORECASE
    Контролирует зависимость всех регулярных выражений и строковых операций от регистра. Если значение IGNORECASE не равно нулю, то при работе с регулярными выражениями регистр будет игнорироваться в следующих случаях: при сравнении строк и проверке шаблонов в правилах; при разделении на поля с использованием значения FS; при разделении на записи с использованием значения RS; в регулярных выражениях c ~ и !~; во встроенных функциях gensub(), gsub(), index(), match(), split() и sub(). Таким образом, если значение IGNORECASE не равно нулю, то /aB/ совпадет с любой строкой из "ab", "aB", "Ab" или "AB". Как и у всех переменных AWK, начальное значение IGNORECASE равно 0, так что все операции со строками и регулярными выражениями изначально чувствительны к регистру. В Unix при игнорировании регистра используется полный набор символов ISO 8859-1 Latin-1. ПРИМЕЧАНИЕ: В версиях gawk до 3.0 значение IGNORECASE влияло только на операции с регулярными выражениями. В данный момент оно влияет и на операции сравнения строк. 
NF
    Количество полей в текущей входной записи. 
NR
    Общее количество встреченных записей. 
OFMT
    Формат вывода чисел. По умолчанию "%.6g". 
OFS
    Разделитель выходных полей. По умолчанию пробел. 
ORS
    Разделитель выходных записей. По умолчанию символ новой строки. 
RS
    Разделитель входных записей. По умолчанию символ новой строки. 
RT
    Конец записи. Gawk присваивает RT значение входного текста, совпавшего с символом или регулярным выражением, содержащимся в RS. 
RSTART
    Индекс первого символа, совпавшего при вызове match(). 0, если совпадения не было. 
RLENGTH
    Длина строки, совпавшей при вызове match(). -1, если совпадения не было. 
SUBSEP
    Символ, используемый для разделения элементов в массиве. По умолчанию "\034". 




ОПЦИИ

Gawk понимает следуюшие опции.
    -F fs 
    --field-separator fs Использовать fs в качестве разделителя полей (значение встроенной переменной FS). 
    -v переменная=значение 
    --assign переменная=значение Присвоить перед выполнением программы значение переменной. Такие переменные доступны в блоке BEGIN программы AWK. 
    -f файл-с-программой 
    --file файл-с-программой Взять программу AWK из файла-с-программой, вместо того, чтобы брать ее из первого аргумента командной строки. Может быть указано несколько опций -f (или --file). 
    -mf NNN 
    -mr NNN Установить различные ограничения памяти в NNN. Флаг f устанавливает максимальное количество полей, а флаг r - максимальный размер записи. Эти два флага опции -m были введены в исследовательской версии Bell Labs UNIX awk. Они игнориуются gawk, так как gawk не имеет предопределенных ограничений. 
    -W traditional 
    -W compat 
    --traditional 
    --compat Работать в режиме совместимости. В этом режиме gawk работает как UNIX awk. Расширения GNU не поддерживаются. Рекомендуется включать этот режим опцией --traditional. Более подробная информация приведена ниже в разделе РАСШИРЕНИЯ GNU. 
    -W copyleft 
    -W copyright 
    --copyleft 
    --copyright Вывести краткую информацию GNU о правах и выйти. 
    -W help 
    -W usage 
    --help 
    --usage Вывести относительно краткую справку по опциям. (В соответствие с GNU Coding Standards, эти опции приводят к немедленному нормальному выходу.) 
    -W lint 
    --lint Выдавать предупреждения о наличии сомнительных или несовместих с другими версиями AWK конструкциях. 
    -W lint-old 
    --lint-old Выдавать предупреждения о наличии конструкций, несовместих со старыми версиями UNIX awk. 
    -W posix 
    --posix Включить режим совместимости со следующими ограничениями:
        *
            Не распознаются экранирующие последовательности \x. 
        *
            Если значение FS - один пробел, то разделителями считаются только пробел и символ табуляции. Символ новой строки разделителем не считается. 
        *
            Не распознается синоним func ключевого слова function. 
        *
            Операторы ** и **= не могут быть использованы вместо ^ и ^=. 
        *
            Недоступна функция fflush(). 
    -W re-interval 
    --re-interval Разрешить использование интервальных выражений в регулярных выражениях. (см. раздел Регулярные выражения ниже). Интервальные выражения традиционно отсутствовали в языке AWK. Стандарт POSIX внес их для совместимости awk и egrep друг с другом. Тем не менее, их использование может привести к ошибкам в работе старых программ AWK, поэтому gawk распознает их только если указана эта опция или опция --posix. 
    -W source текст-программы 
    --source текст-программы Использовать текст-программы в качестве текста программы AWK. Эта опция позволяет совмещать вызовы библиотечных функций (подключаемых через опции -f и --file) с исходным кодом, вводимым в командной строке. Эта опция, в первую очередь, предназначена для средних и больших по размеру программ AWK, используемых в скриптах shell. 
    -W version 
    --version Вывести информацию о версии вашей копии gawk. Эта опция может быть полезна, если вы хотите узнать, не устарел ли gawk, установленный в вашей системе, а также если вы хотите сообщить об ошибке. (В соответствие с GNU Coding Standards, эти опции приводят к немедленному нормальному выходу.) 
-- 
    Конец опций. Эта опция используется для возможности обработки аргументов, начинающихся с ``-'', непосредственно программой AWK, что соответствует соглашению об обработке аргументов, используемому большинством других программ, совместимых со стандартом POSIX. 

Регулярные выражения AWK - это расширенная версия регулярных выражений egrep. Они составляются из символов следующим образом:
c
    совпадает с не-метасимволом c. 
\c
    совпадает с символом c. 
.
    совпадает с любым символом, включая символ начала строки. 
^
    совпадает с началом строки. 
$
    совпадает с концом строки. 
[abc...]
    список символов, совпадает с любыми символоми abc.... 
[^abc...]
    инвертированный список символов, совпадает с любыми символами, кроме abc.... 
r1|r2
    альтернатива: совпадает либо с r1, либо с r2. 
r1r2
    сцепление: совпадает сперва с r1, затем с r2. 
r+
    совпадает с одним или более r. 
r*
    совпадает с ноль или более r. 
r?
    совпадает с ноль или одним r. 
(r)
    группирование: совпадает с r. 
    r{n} 
    r{n,} 
    r{n,m} Одно или два числа в фигурных скобках обозначают интервальное выражение. Если в скобках указано одно число, то предыдущее регулярное выражение r повторяется n раз. Если указаны два числа, разделенные запятой, то r повторяется от n до m раз. Если указано только одно число после запятой, то r повторяется, как минимум, n раз.
    Интервальные выражения можно использовать, только если в командной строке указана либо опция --posix, либо --re-interval. 
\y
    совпадает с пустой строкой либо в начале, либо в конце слова. 
\B
    совпадает с пустой строкой в слове. 
\<
    совпадает с пустой строкой в начале слова. 
\>
    совпадает с пустой строкой в конце слова. 
\w
    совпадает с любым текстовым символом (буква, цифра или подчеркивание). 
\W
    совпадает с любым нетекстовым символом. 
\`
    совпадает с пустой строкой в начале буфера (строки). 
\'
    совпадает с пустой строкой в конце буфера. 
[:alnum:]
    Текстовые символы (буквы, цифры, подчеркивание). 
[:alpha:]
    Алфавитные символы. 
[:blank:]
    Символы пробела или табуляции. 
[:cntrl:]
    Управляющие символы. 
[:digit:]
    Символы цифр. 
[:graph:]
    Символы одновременно и видимые, и печатаемые. (Пробел печатаем, но не видим, в то время, как a - и то и другое.) 
[:lower:]
    Алфавитные символы нижнего регистра. 
[:print:]
    Печатаемые символы (не являющиеся управляющими). 
[:punct:]
    Знаки препинания (не буквы, не цифры, не управляющие символы и не пробел). 
[:space:]
    Символы пробела (такие, как пробел, табуляция, перевод формата). 
[:upper:]
    Алфавитные символы верхнего регистра. 
[:xdigit:]
    Символы, являющиеся шестнадцатеричными цифрами. 
Без опций
    По умолчанию, gawk предоставляет все возможности регулярных выражений POSIX и операторов GNU для регулярных выражений, как описано выше. Не поддерживаются лишь интервальные выражения. 
--posix
    Поддерживаются лишь регулярные выражения POSIX, операторы GNU не имеют специального значения. (Например, \w соответствует букве w). Интервальные выражения разрешены. 
--traditional
    Используются традиционные регулярные выражения Unix awk. Операторы GNU не имеют специального значения, интервальные выражения не поддерживаются, классы символов POSIX ([[:alnum:]] и т. д.) не поддерживаются. Символы, указанные с помощью восьмиричной или шестнадцатиричной экранирующей последовательности, воспринимаются буквально, даже если они представляют собой метасимволы регулярных выражений. 
--re-interval
    Позволяет использовать интервальные выражения, даже если указана опция --traditional. 

AWK определены следующие операции, в порядке убывания приоритета,
(...)
    Группирование 
$
    Ссылка на поле. 
++ --
    Инкремент и декремент, оба могут быть префиксными и постфиксными. 
^
    Возведение в степень (можно также использовать ** и **= с оператором присваивания). 
+ - !
    Унарный плюс, унарный минус и логическое отрицание. 
* / %
    Умножение, деление и модуль. 
+ -
    Сложение и вычитание. 
пробел
    Сцепление строк. 
    < > 
    <= >= 
    != == Обычные операции сравнения. 
~ !~
    Совпадение и несовпадение регулярного выражения. ПРИМЕЧАНИЕ: Не используйте регулярное выражение-константу (/foo/) слева от ~ или от !~, только справа. Выражение /foo/~выражение имеет то же значение, что и (($0 ~ /foo/) ~ выражение). Обычно это не то, что предполагалось. 
in
    Существование в массиве. 
&&
    Логическое И. 
||
    Логическое ИЛИ. 
?:
    Условное выражение C. Оно имеет вид выражение1 ? выражение2 : выражение3. Если выражение1 является истиной, то результатом является выражение2, в противном случае - выражение3. Вычисляется либо выражение2, либо выражение3. 
    = += -= 
    *= /= %= ^= Присваивание. Поддерживается как простое присваивание (переменная=значение), так и сложные виды присваивания (операция-присваивание). 

  Управляющими операторами являются:
    if (условие) оператор [ else оператор ]
    while (условие) оператор
    do оператор while (условие)
    for (выражение1; выражение2; выражение3) оператор
    for (переменная in массив) оператор
    break
    continue
    delete массив[индекс]
    delete массив
    exit [ выражение ]
    { операторы }

 Операторами ввода/вывода являются:
close(файл)
    Закрыть файл (или канал, см. ниже). 
getline
    Считать следующую запись в $0. Установить NF, NR, FNR. 
getline <файл
    Считать следующую запись файла в $0. Установить NF. 
getline переменная
    Считать следующую запись в переменную. Установить NR, FNR. 
getline переменная <файл
    Считать следующую запись файла в переменную. 
next
    Прекратить обработку текущей входной записи. Считать следующую входную запись и начать ее обработку с первого шаблона программы AWK. Если обработаны все входные данные, то выполнить блок(и) END, если таковые имеются. 
nextfile
    Прекратить обработку текущего входного файла. Следующая входная запись будет прочитана из следующего входного файла. FILENAME и ARGIND обновляются, FNR присваивается 1, обработка начинается с первого шаблона программы AWK. Если обработаны все входные данные, то выполнить блок(и) END, если таковые имеются. ПРИМЕЧАНИЕ: В ранних версиях gawk использовалась конструкция next file (в два слова). Хотя эта конструкция все еще распознается, выдается предупреждающее сообщение. В конечном счете, она не будет поддерживаться. 
print
    Вывести текущую запись. Запись оканчивается содержимым переменной ORS. 
print список-выражений
    Вывести выражения. Выражения разделяются содержимым переменной OFS. Запись оканчивается содержимым переменной ORS. 
print список-выражений >файл
    Вывести выражения в файл. Выражения разделяются содержимым переменной OFS. Запись оканчивается содержимым переменной ORS. 
printf формат, список-выражений
    Отформатировать и вывести. 
printf формат, список-выражений >файл
    Отформатировать и вывести в файл. 
system(командная-строка)
    Выполнить команду, указанную в командной-строке, и вернуть код выхода из команды. (Может не работать на не-POSIX системах.) 
fflush([файл])
    Сбросить буфера, связанные с открытым для записи файлом или каналом файл. Если файл не указан, происходит сброс буферов стандартного потока вывода. Если файл - пустая строка, то происходит сброс буферов всех открытых файлов и каналов. 

 AWK версии оператора printf и функции sprintf() (см. ниже) воспринимают следующие форматы:
%c
    ASCII символ. Если аргумент %c является числом, то он интерпретируется как символ и выводится. В противном случае, аргумент интерпретируется как строка, и выводится только первый символ этой строки. 
    %d 
    %i Десятичное число (целая часть). 
    %e 
    %E Число с плавающей запятой в виде [-]d.dddddde[+-]dd. Формат %E использует E вместо e. 
%f
    Число с плавающей запятой в виде [-]ddd.dddddd. 
    %g 
    %G Использовать либо формат %e, либо формат %f, в зависимости от того, что короче. Незначащие нули не выводятся. Формат %G испольует %E вместо %e. 
%o
    Беззнаковое восьмиричное число (целое). 
%s
    Строка символов. 
    %x 
    %X Шестнадцатиричное число (целое). Формат %X использует ABCDEF вместо abcdef. 
%%
    Один символ %. Преобразование аргумента не производится. 

Возможно указание дополнительных, необязательных параметров между символом % и буквой формата:
-
    Выражение должно быть выравнено по левой границе поля. 
пробел
    Для числовых преобразований; выводить перед положительными значениями пробел, перед отрицательными - знак минуса. 
+
    Знак плюса, указанный перед параметром ширины (см. ниже), предписывает всегда выводить знак для числовых преобразований, даже если форматируемые данные имеют положительное значение. + аннулирует параметр пробел. 
#
    Использовать ``альтернативный вид'' для некоторых форматов. Для %o - вывести впереди ноль. Для %x и %X - вывести впереди 0x или 0X, если результат отличен от нуля. Для %e, %E и %f - результат всегда будет содержать десятичную запятую. Для %g и %G - конечные нули не будут убраны из результата. 
0
    Ведущий 0 (ноль) служит признаком того, что выводимое поле должно быть заполнено нулями, а не пробелами. Это относится ко всем нечисловым форматам вывода. Признак влияет, только если ширина поля превышает ширину выводимого значения. 
ширина
    Поле должно быть заполнено до этой ширины. Обычно поле заполняется пробелами. Если указан параметр 0, то поле будет заполнено нулями. 
.точность
    Число определяет точность вывода. Для форматов %e, %E и %f указывается количество цифр, выводимых справа от десятичной запятой. Для форматов %g и %G указывается максимальное количество значащих цифр. Для форматов %d, %o, %i, %u, %x и %X указывается минимальное количество выводимых цифр. Для строки указывается максимальное количество выводимых символов строки. 

 Gawk имеет следующие встроенные строковые функции:
gensub(r, s, h [, t])
    ищет в строке t совпадения с регулярным выражением r. Если h является строкой, начинающейся с g или G, то заменяет все совпадения r на s. В противном случае, h является числом, указывающим, которое по счету совпадение r заменять. Если t не указано, то используется $0. В тексте замены s последовательность \n, где n - это цифра от 1 до 9, может быть использована для ссылки на текст n-ного, заключенного в скобки, подвыражения. Последовательность \0 ссылается на весь совпавший текст, как и символ &. В отличие от sub() и gsub(), измененная строка возвращается как результат функции, а исходная строка не изменяется. 
gsub(r, s [, t])
    каждую подстроку строки t, совпавшую с регулярным выражением r, заменяет на строку s и возвращает количество осуществленных замен. Если t не указана, то используется $0. Вместо & в тексте замены подставляется совпавшая строка. Для вывода символа & используйте \&. За полной информацией о правилах для & и \ в тексте замены в sub(), gsub() и gensub(), обращайтесь к AWK Language Programming. 
index(s, t)
    возвращает индекс строки t в строке s, или 0, если t не найдена. 
length([s])
    возвращает длину строки s или, если s не указана, длину $0. 
match(s, r)
    возвращает позицию, с которой регулярное выражение r совпадает с s или, если r не совпадает, 0. Устанавливает значения RSTART и RLENGTH. 
split(s, a [, r])
    разбивает строку s на основе регулярного выражения r, помещает результат в массив a и возвращает количество полей. Если r не указано, то используется FS. Массив a предварительно очищается. Функция работает подобно разбивке на поля, описанной выше. 
sprintf(fmt, expr-list)
    выводит список-выражений в соответствии с форматом и возвращает получившуюся строку. 
sub(r, s [, t])
    то же, что и gsub(), но заменяется только первая совпавшая подстрока. 
substr(s, i [, n])
    возвращает n-символьную подстроку строки s, начиная с i. Если n не указано, то возвращается остаток строки s. 
tolower(строка)
    возвращает копию строки, в которой все символы верхнего регистра, встречающиеся в строке, переведены в соответствующие им символы нижнего регистра. Неалфавитные символы остаются без изменений. 
toupper(str)
    возвращает копию строки, в которой все символы нижнего регистра, встречающиеся в строке, переведены в соответствующие им символы верхнего регистра. Неалфавитные символы остаются без изменений. 




ls -l files | awk '{ x += $4 } ; END { print "total bytes: " x }'      Prints the total number of bytes used by files.
gawk 'length($0) > 80'               Prints every line longer than 80 characters.
$ lspci -v | awk '/VGA/,/^$/'                     
$ awk -F":" '{ print "username: " $1 "\t\tuid:" $3" }' /etc/passwd
$ awk -f myscript.awk myfile.in
        BEGIN { 
            FS=":" 
        } 
        { print $1 }
# Print all lines between start/stop pairs:
  awk '/start/, /stop/' file













