Sed

Из-за своей потоковой природы, sed может выполнять операции над данными, полученными из стандартного потока ввода (stdin),
Sed работает путем формирования некоторого набора операций для редактирования, указанных пользователем (назовем ее - команда), над входными данными. Sed работает построчно, т.е. команда выполняется над каждой строкой в порядке их поступления. И затем sed записывает результат преобразования в стандартный поток вывода (stdout); при этом модификация исходных данных (например, входного файла) не происходит.
sed, указав ему одну команду для редактирования - 'd'. Sed открыл файл /etc/services, прочитал строку в свой внутренний буфер, выполнил нашу команду ("удалить строку" - от delete line) и затем вывел содержимое буфера (который стал пустым после выполнения команды). Затем эта операция повторилась для следующей строки. Затем еще для одной и так до тех пор, пока sed не добрался до конца файла. Таким образом, команда 'd' затирает каждую строку в буфере sed!
sed читает строку за строкой в свой внутренний буфер, называемый "буфер шаблонов". Когда строка прочитана и помещена в буфер, sed выполняет команду над его содержимым и печатает результат (в нашем примере это пустая строка)
выполняет сравнение строки с регулярным выражением, то он ищет самую длинную подстроку, совпадающую с ним.

    &                     Этот символ указывает sed, что необходимо вставить всю подстроку, совпавшую с регулярным выражением. Итак, все, что совпало с '.*' (самая длинная группа из нуля или более символов в строке, другими словами - вся строка) может быть вставлено везде в строке замены, причем даже несколько раз.

Символ & (амперсанд), будучи помещен в состав ЗАМЕНЫ, означает любой найденный в тексте ОБРАЗЕЦ. Например:
$ echo 1234 | sed 's/[0-9]*/(&)/'
(1234)

Звездочка (астериск) после интервала [0-9] нужна чтобы заменены были все цифры, встретившиеся в образце. Без нее получилось бы:
$ echo 1234 | sed 's/[0-9]/(&)/'
(1)234

$ sed -e 's/\(.*\) \(.*\) \(.*\)/Victor \1-\2 Von \3/' myfile.txt
в данном случае определены три логические группы, на которые мы можем ссылаться в строке замены мы ссылаемся на каждую группу, заданную в круглых скобках, с помощью выражения '\x', где 'x' номер группы, начинающийся с единицы.

 '=', которая указывает sed печатать номер строки, также как команда 'p', которая указывает sed печатать всю строку (когда мы в режиме '-n'):
$ sed -n -e '=;p' myfile.txt
Во всех случаях, когда указываются две или более команды для sed, то каждая команда применяется к каждой строке файла (в том порядке, в котором они заданы). В вышеописанном примере к строке 1 сначала применяется команда '=', затем применяется команда 'p'. Далее sed переходит к обработке второй строки и процесс повторяется. Использование точки с запятой в качестве разделителя хоть и удобно, но есть ситуации, когда применять ее не представляется возможным. Поэтому есть альтернативный способ для отделения нескольких команд друг от друга, а именно использовать опцию -e для каждой команды:
$ sed -n -e '=' -e 'p' myfile.txt
Для сложных многострочных скриптов лучшим выходом будет сохранение команд в отдельные файлы, на которые можно ссылаться с помощью опции -f:
$ sed -n -f mycommands.sed myfile.txt
sed -r '....... ' $filename   использование расширенных регулярных выражений

sed -e '/.*/i\input string' $filename     вставляют строку после текущей
sed -e '/.*/a\input string' $filename    vставляет строку или строки после текущей строки, соответствующей заданному шаблону.
sed -e '/.*/c\input string' $filename   "изменить строку" фактически заменяет содержимое текущей строки в рамках совпадения с шаблоном
s/<<:cntrl:>>//g                            
/^D/ {                                                     Как только sed найдет совпадение с адресом,
s/^D\(.*\)/\1\tOUTY\tINNY\t/                  то над буфером шаблона будут выполняться команды, заключенные в фигурные скобки
s:^\(.*\)/\(.*\)/\(.*\):\2 \1 \3:                       в порядке их расположения. И так с каждой прочитанной строкой.
}
'N' указывает sed, что нужно прочитать следующую строку и добавить ее в буфер шаблона.

sed -e -n '/^function/,/^}/!H;/^function/,/^}/p;${х;р;}' filename
! для изменения значения условия на противоположное.Команда Н добавляет содержимое буфера шаблона в буфер захвата. Таким образом, она помещает в буфер захвата все строки, которые находятся за пределами определения функции.Вторая строка выводит строки, которые находятся внутри определения функции (чтобы они шли первыми, как и требуется).Наконец, в последней строке используется обозначение $, символизирующее последнюю строку ввода. Команда помещает содержимое буфера захвата в буфер шаблона и выводит его.


http://info-linux.ru/images/forArticle/sed_2.jpg

-e 'скрипт' - задаёт скрипт обработки данных в виде строки. Скрипт можно написать на нескольких строках! 
-e может быть опущен, если он присутствует один. 
-f файл-со-скриптом - задаёт файл со скриптом.
-r - использовать расширенные регулярные выражения (более удобно на мой взгляд)
-n - не выводить текст пока мы явно об этом не попросим в скрипте.

наверное, знаете, текстовые файлы DOS/Windows имеют в конце каждой строки символ CR (carriage return - возврат каретки) и LF (line feed - перевод строки), а текстовые файлы UNIX содержат только символ LF. 

-n [диапазон строк]/p 	                         print 	Печать [указанного диапазона строк]
[диапазон строк]/d 	                       delete 	Удалить [указанный диапазон строк]
s/pattern1/pattern2/ 	                   substitute 	Заменить первое встреченное соответствие шаблону pattern1, в строке, на pattern2
[диапазон строк]/s/pattern1/pattern2/ 	substitute 	Заменить первое встреченное соответствие шаблону pattern1, на pattern2, в указанном диапазоне строк
[диапазон строк]/y/pattern1/pattern2/ 	transform 	заменить любые символы из шаблона pattern1 на соответствующие символы из pattern2, в указанном диапазоне строк (эквивалент команды tr)
g 	                                       global 	Операция выполняется над всеми найденными соответствиями внутри каждой из заданных строк
g - во всей строке
i - без учёта регистра
p - выводить результат замены
w wfile 	сохранять заменяемое в "wfile". 



sed -e '/^$/d' $filename
 ключ -e для того, чтобы определить, что следующая строка является инструкцией, или набором инструкций, редактирования. Если инструкция является единственной, то использование этого ключа не является обязательным.
# (При передаче одной инструкции, ключ "-e" является необязательным.)
#  "Строгие" кавычки ('') предотвращают интерпретацию символов регулярного выражения,
#+ как специальных символов, командным интерпретатором.
#
# Действия производятся над строками, содержащимися в файле $filename.

sed -n '/xzy/p' $filename
# Ключ -n заставляет sed вывести только те строки, которые совпадают с указанным шаблоном.
# В противном случае (без ключа -n), будут выведены все строки.
'-n', который не дает sed выводить буфер шаблона, пока не будет явно указано
# Здесь, ключ -e не является обязательным, поскольку здесь стоит единственная команда.

Тогда sed будет действовать следующим образом: выведет все строки, начиная с совпадения с первым регулярным выражением, до тех пор, пока не будет найдено совпадение со вторым регулярным выражением. Например, следующая команда напечатает текстовый блок, который начинается со строки, содержащей слово "BEGIN" и заканчивается строкой, содержащей слово "END":
                $ sed -n -e '/BEGIN/,/END/p' /my/test/file | more
Если "BEGIN" не найдено, то вывода не будет. Если же "BEGIN" найдено, но ниже ни в одной строке не встречается "END", то будут напечатаны все последующие строки. Это происходит из-за потоко-ориентированной природы sed — она не знает, встретит еще "END" или нет, и поэтому выводит весь текст, пока не найдет нужное слово.


$ sed -e '/^$/,/^END/s/hills/mountains/g' myfile3.txt замена слова "hills" на слово "mountains", но только в том блоке текста, который начинается с пустой строки и заканчивается строкой, начинающейся с трех символов 'END' включительно.
8d 	Удалить 8-ю строку.
/^$/d 	Удалить все пустые строки.
1,/^$/d 	Удалить все строки до первой пустой строки, включительно.
/Jones/p 	Вывести строки, содержащие "Jones" (с ключом -n).
s/Windows/Linux/ 	В каждой строке, заменить первое встретившееся слово "Windows" на слово "Linux".
s/BSOD/stability/g 	В каждой строке, заменить все встретившиеся слова "BSOD" на "stability".
s/ *$// 	Удалить все пробелы в конце каждой строки.
s/00*/0/g 	Заменить все последовательности ведущих нулей одним символом "0".
/GUI/d 	Удалить все строки, содержащие "GUI".
s/GUI//g 	Удалить все найденные "GUI", оставляя остальную часть строки без изменений.
Добавить в конец файла "[mounts]" затем перенос на новую строка и "user root".
    sed -i '$ a \\n[mounts]\nuser root' /etc/munin/config 
После 14ой строки добавить "echo "graph_category logger"".
    sed '14a\ echo \"graph_category logger\"' /etc/munin/plugins/command 
Вставить в начало файла '# vim: ft=ruby' и перенос строки.
    $ sed '1i # vim: ft=ruby\n'  
Заменить повторяющиеся пустые строки на одну пустую строку
    $ sed -e ':a;/^$/N;/\n$/{D;ba}' file.txt
Изменить строку anystring1 на anystring2
    $ sed 's/\(.*\)1/\12/g'
Убрать комментарии и пустые строки
     sed '/ *#/d; /^ *$/d'
Удалить предшествующие пробелы с строк
    $ sed 's/[ \t]*$//'
Напечатать 1000-ную строку
     sed -n '1000p;1000q'
Получить title из HTML страницы
    $ sed -n 's/.*<title>\(.*\)<\/title>.*/\1/ip;T;q'
Удалить каждую вторую строку:
          sed 'n;d'
Удалить  все  пробелы  и  символы табуляции в начале каждой строки файла (смотрите примечание по табуляции в конце документа):
          sed 's/^[ \t]*//'
Удалить  все  пробелы  и  символы  табуляции в конце каждой строки файла (смотрите примечание по табуляции в конце документа):
          sed 's/[ \t]*$//'
Поиск и замеа "foo" на "bar" в каждой строке:
          sed 's/foo/bar/' (замена только первого совпадения в строке)
          sed 's/foo/bar/4' (замена первых 4рех совпадений в строке)
          sed 's/foo/bar/g' (замена ВСЕХ совпадений в строке)
Замена "foo" на "bar" ТОЛЬКО для строк содержащих "baz":
          sed '/baz/s/foo/bar/g'
Замена "foo" на "bar" ИСКЛЮЧАЯ строки содержащие "baz":
          sed '/baz/!s/foo/bar/g'
Замена "scarlet" или "ruby", или "puce" на "red":
          sed  's/scarlet/red/g;s/ruby/red/g;s/puce/red/g' (большинство  sed-ов)
          gsed 's/scarlet\|ruby\|puce/red/g' (только GNU sed)
Если   линия   заканчиваеться   обратной   косой  чертой  "\",  то присоеденить следующую линию:
          sed -e :a -e '/\\$/N; s/\\\n//; ta'
Если   линия  начинаеться  с  знака  "=",  то  присоеденить  ее  к предыдущей линии и заменить "=" пробелом:
          sed -e :a -e '$!N;s/\n=/ /;ta' -e 'P;D'
Добавить  запятые к числу с десятичной частью и знаком минуса (GNU sed):
          gsed -r ':a;s/(^|[^0-9.])([0-9]+)([0-9]{3})/\1\2,\3/g;ta'
Печатать первые 10 линий файла (эмуляция "head"):
          sed 10q
Печатать первую строку файла (эмуляция "head -1"):
          sed q
Печатать последние 10 строк файла (эмуляция "tail"):
          sed -e :a -e '$q;N;11,$D;ba'
Печатать последние 2 строки файла (эмуляция "tail -2"):
          sed '$!N;$!D'
Печатать последнюю строку файла (эмуляция "tail -1"):
          sed '$!d'
Печатать  только  те  строки,  которые  НЕ  совпадают с регулярным выражением (эмуляция "grep -v"):
          sed -n '/regexp/!p' - Версия 1, corresponds to above
          sed '/regexp/d' - Версия 2, simpler syntax
Печать строк, совпадающих с регулярными выражениями AAA, BBB и CCC  одновременно (в любой последовательности):
          sed '/AAA/!d; /BBB/!d; /CCC/!d'
Печать строк, совпадающих с регулярными выражениями AAA, BBB и CCC  одновременно (в конкретной последовательности):
          sed '/AAA.*BBB.*CCC/!d'
Печать  строк,  совпадающих  с любым регулярным выражением AAA или   BBB, или CCC (эмуляция "egrep"):
          sed  -e  '/AAA/b'  -e  '/BBB/b' -e '/CCC/b' -e d (большинство sed'ов)
          gsed '/AAA\|BBB\|CCC/!d' (только GNU sed)
Печатать  абзац  если  он  содержит  AAA  (пустая строка разделяетабзацы) (в HHsed v1.5 необходимо вставить 'G;' после 'x;'):
          sed -e '/./{H;$!d;}' -e 'x;/AAA/!d;'
Печатать строки длиной равной или большей 65 символов:
          sed -n '/^.\{65\}/p'
Печатать строки длиной меньше или равной 65 символов:
          sed -n '/^.\{65\}/!p' - Версия 1, отвечает условию
          sed '/^.\{65\}/d' - Версия 2, более простой синтаксис
Печатать строку под номером 52:
          sed -n '52p' - Версия 1
          sed '52!d' - Версия 2
          sed '52q;d' - Версия 3, эффективен на больших файлах
Удалить   дубликаты   последовательных  строк  в  файле  (эмуляция"uniq").  Первая строка в наборе дубликатах строк удерживаеться от
     удаления:
          sed '$!N; /^\(.*\)\n\1$/!P; D'
Удалить  дубликаты непоследовательных строк в файле. Остерегайтесь  переполнения  буфера  или  используйте  GNU  sed:  (Beware  not to  overflow the buffer size of the hold space)
          sed -n 'G; s/\n/&&/; /^\([ -~]*\n\).*\n\1/d; s/\n//; h; P'
Печатать только дубликаты строк (эмуляция "uniq -d").:
          sed '$!N; s/^\(.*\)\n\1$/\1/; t; D'
Удалить первые 10 строк в файле:
          sed '1,10d'
Удалить последнюю строку в файле:
          sed '$d'
Удалить 2 последние строки файла:
          sed 'N;$!P;$!D;$d'
Удалить последние 10 строк файла:
          sed -e :a -e '$d;N;2,10ba' -e 'P;D
Оставить   последовательность   пустых   строк   не   более   двух  одновременно:
          sed '/^$/N;/\n$/N;//D'
Удалить все пустые строки в начале файла:
          sed '/./,$!d'
Удалить все пустые строки в конце файла:
          sed -e :a -e '/^\n*$/{$d;N;ba' -e '}' (для всех sed-ов)
          sed -e :a -e '/^\n*$/N;/\n$/ba' (для всех, кроме gsed 3.02.*)
Удалить  конкретный  символ  (к  примеру:  символ возврата) из man страницы.  Для  использования  комманда 'echo' может потребоваться указать  параметр  -e  (если  вы  используете  Unix  System  V или  оболочку bash):
          sed  "s/.`echo  \\\b`//g"  (двойные кавычки необходимы в Unix окружении)
          sed 's/.^H//g' (в bash/tcsh, нажмите Ctrl-V и затем Ctrl-H)
          sed 's/.\x08//g' (hex выражение для sed 1.5, GNU sed, ssed)
Получить заголовок Usenet/e-mail сообщения:
          sed '/^$/q' (удаляет все после первой пустой строки)
Получить тело Usenet/e-mail сообщений:
          sed '1,/^$/d' (удаляет все до первой пустой строки)
Получить  заголовок  Subject  (тема  Usenet/e-mail сообщения), без   удаления части "Subject: ":
          sed '/^Subject: */!d; s///;q'
Получить заголовок обратный адрес:
          sed '/^Reply-To:/q; /^From:/h; /./d;g;q'
sed '/^$/q'	      Получает заголовок письма
sed '1,/^$/d'	Получает тело письма
Анализировать  правильный  исходящий адрес. # Pulls out the e-mail address  by  itself  from  the  1-line  return address header (see     preceding script):
          sed 's/ *(.*)//; s/>.*//; s/.*[:<] *//'
Извлечение   закодированных   (uuencoded)   двоичных   данных   из   нескольких  частей, удаление внешней заголовочной информации. Итак  это  только часть закодированного остатка. Файлы пропущенные через  sed  должны быть пропущены в правильной последовательности. Версия 1  может  быть  введена  из коммандной строки, версия 2 может быть встроена  в  исполняемый скрипт оболочки Unix. (Модифицированна из     скрипта Rahul Dhesi):
          sed  '/^end/,/^begin/d'  file1  file2 ... fileX | uudecode
     или          sed '/^end/,/^begin/d' "$@" | uudecode
zip  up  each  .TXT file individually, deleting the source file and setting  the  name  of each .ZIP file to the basename of the .TXT file
   (under  DOS: the "dir /b" switch returns bare filenames in all caps).:
             echo @echo off >zipup.bat
          dir /b *.txt | sed  "s/^\(.*\)\.TXT/pkzip -mo \1  \1.TXT/" >> zipup.bat
sed '0,/RE/{//d;}' file.txt	Удаляет только первое соответствие
sed '0,/RE/s//to_that/' file.txt	Изменяет только первое соответствие
sed -n '/RE/{p;q;}' file.txt	Печатает только первое соответствие RE (регулярного выражения)
sed '/./,$!d' file.txt	Удалить все начальные пустые строки
sed '/./,/^$/!d' file.txt	Удалить все последовательные пустые строки за исключением EOF
sed '17,/disk/d' file.txt	Удаляет все строки, начиная с 17-й, до "disk"
sed '/boom/!s/aaa/bb/' file.txt	Если найден "boom", заменить aaa на bb
sed '/[0-9]\{3\}/p' file.txt	Печатает только строки с тремя последовательными цифрами
sed '/regex/{x;p;x;}'Вставить   пустую  строку  перед  каждой  строкой  соответствующей регулярному выражению "regex":
sed '/regex/G' Вставить   пустую   строку  после  каждой  строки  соответствующей регулярному выражению "regex":
sed '/regex/{x;p;x;G;}' Вставить пустую строку перед и после каждой строки соответствующей регулярному выражению "regex":        
sed '/baz/s/foo/bar/g'  Замена "foo" на "bar" ТОЛЬКО для строк содержащих "baz":
sed '/baz/!s/foo/bar/g'  Замена "foo" на "bar" ИСКЛЮЧАЯ строки содержащие "baz":
sed -n '/regexp/{g;1!p;};h'  Печатать строку непосредственно перед регулярным выражением, но не печатать строку содержащую регулярное выражение:
sed -n '/regexp/{n;p;}'  Печатать строку непосредственно после регулярного выражения, но не печатать строку содержащую регулярное выражение:
sed -n -e '/regexp/{=;x;1!p;g;$!N;p;D;}' -e h Печатать  по  одной  строке перед и после регулярного выражения, с указанием   номера  строки  совпадающей  с  регулярным  выражением (симуляция "grep -A1 -B1"):         

Можно комбинировать цифровой модификатор с модификатором /g. Если нужно оставить неизменным первое слово, а второе и последующие заменить на слово "(удалено)", то команда будет такая:
$ echo очень глупый пингвин | sed 's/[а-я]*/(удалено)/2g'
очень (удалено) (удалено)

Если нужно действительно удалить все последующие совпадения, кроме первого, то в секции ЗАМЕНЫ следует поставить пробел:
$ echo очень глупый пингвин | sed 's/[а-я]*/ /2g'
очень
     

          


     

                   


    

          

     

        


     

         




Символ обратного слэша представляет символ перевода строки, как символ замены. В этом случае, замещающее выражение продолжается на следующей строке.
s/^  */\
/g
Эта инструкция заменит начальные пробелы в строке на символ перевода строки. Ожидаемый результат -- замена отступов в начале параграфа пустыми строками.
5,$d   для удаления строк с 5-й по последнюю {$ — обозначение последней строки в файле)




Цикл выполнения
sed работает с двумя буферами данных: основным и вспомогательным. Изначально оба буфера пусты.
Работа с этими буферами осуществляется при помощи команд:\`h', `H', `x', `g', `G' `D' 
h - Заменить содержимое вспомогательного буфера содержимым основного
H - Добавить сим. новую строку к вспомогательному буферу и затем добавить содержимое основного буфера к содержимому вспомогательного
x - Поменять содержимое обоих буферов местами
g - Заменить содержимое основного буфера содержимым вспомогательного
G - Добавить новую строку к основному буферу и затем добавить содержимое вспомогательного буфера к содержимому основного
D - Удалить текст основного буфера до следующего символа перевода строки
N - Добавить сим. новую строку к основному буферу, затем добавить туда следующую обрабатываемую строку
P - Вывести содержимое основного буфера до следующего символа перевода строки
http://info-linux.ru/images/forArticle/sed_2.jpg
http://info-linux.ru/article/133

                            -------------------------------------------
             input ---> |       ОСНОВНОЙ                       |   ---  p ------> stdout
                            |        БУФЕР  (ШАБЛОНА)       |   ---  w ------> file
                            ------------------------------------------
                              |        |        ^        ^        ^     
                           h |    H  |     x |      g |     G |  
                             \/       \/                 |         |
                            -------------------------------------------
                            |       ВСПОМОГАТЕЛЬНЫЙ     |
                            |        БУФЕР  (ЗАХВАТА)         |
                            ------------------------------------------



Метки
: метка - сопоставить группе команд метку
b метка - переход к команде, обозначенной меткой метка, если метка отсутствует, то переход в конец командного файла.
t метка - переход к команде, обозначенной меткой метка только после удачной замены с помощью команды s///

/AMT-<0-9>*.<0-9>*AMT/b fixnegs
:fixnegs
cоответствует формату "/регулярное выражение/b метка". Если буфер шаблона совпадает с регулярным выражением, то sed переходит к метке fixnegs.

/./	Совпадение с любой строкой, содержащей хотя бы один символ.
/../	Совпадение с любой строкой, содержащей хотя бы два символа.
/^#/	Совпадение с любой строкой, начинающейся с символа '#'.
/^$/	Совпадение с любой пустой строкой.
/} *$/	Совпадение с любой строкой, которая завершается символом '}' за которым следует ноль или более пробелов.


sed -rne '
/  |\t/ {
x # меняем местами обе области
  s/\n//g # удалим все лишние переводы строки
  s/.*// # обнуляем область редактирования (d не подходит)
  x # снова меняем местами обе области местами - и мы готовы дальше работать с первой строкой параграфа
}
/  |\t/ ! H
$ {
x # меняем местами обе области
   s/\n//g # удалим все лишние переводы строки
   p # выводим область редактирования
}
'


Функции SED
(В скобках указывается максимальное число адресов)
(1) a \text - Добавить "text" после указанной строки (вывести), потом считать следующую.
(2) b label - Перейти на метку, устанавливаемую, с помощью функции ":" , если label пуст, то перейти в конец скрипта.
(2) c \text - Удалить pattern space и вывести "text" на output .
(2) d - Удалить pattern space .
(2) D - Удалить pattern space до вставленной newline .
(2) g - Заместить содержимое pattern space содержимым буфера hold space .
(2) G - Добавить к содержимому pattern space содержимое буфера hold space .
(2) h - Заместить содержимое буфера hold space на содержимое pattern space .
(2) H - Добавить к содержимому буфера hold space содержимое pattern space .
(1) i \text - Вывести текст на output перед указанной строкой.
(2) n - Вывести pattern space на output и считать следующую строку.
(2) N - Добавить следующую строку к pattern space , разделяя строки вставленным newline .
(2) p - Скопировать pattern space на output .
(2) P - Скопировать pattern space до первой вставленной newline на output .
(1) q - Переход на конец input . Вывести указанную строку, (если нет флага -n ) и завершить работу SED .
(2) r rfile - Читать содержимое rfile и вывести его на output прежде чтения следующей строки.
(2) s - Функция контекстной замены. (См. 5.)
(2) t label - Перейти на метку, устанавливаемую с помощью функции ":" , если для этой строки была осуществлена замена с помощью функции "s" . Флаг осуществления замены восстанавливается при чтении следующей строки или при выполнении функции "s" .
(2) w wfile - Добавить pattern space к концу файла wfile . (Максимально можно использовать до 10 открытых файлов.)
(2) x - Поменять местами содержимое pattern space и буфера hold space .
(2) y /str1/str2/ - Заменить все вхождения символов из str1 на соответствующие из str2 . Длины строк должны быть равными.
(2) ! func - Применять функцию func (или группу функций в {} ) к стокам НЕ попадающим в указанные адреса.
(0) : label - Устанавливает метку для перехода по "b" и "t" командам.
(1) = - Выводит номер строки на output как строку.
(2) { - Выполняет функции до "}" , только когда выбрано pattern space . Группировка функций.
(0) - Пустая команда игнорируется.
# - Комментарий.
( "#n" в скрипте равносильно установке флага -n ) 