#!/bin/bash

N=1
for ARG in "$@"; do
echo "Входной параметр #$N = $ARG"; N=$[$N+1]
done

[ -z "$*" ] && ...
ARGS=2
if [ $# -ne "$ARGS" ] # Проверка количества входных аргументов.

[ "$(whoami)" != 'root' ] && ( echo У вас нет прав для запуска; exit 1 )

делать что-то если в аргументе не буква
ARG=${1//[a-zA-z/}
[ -z "$ARG" ] && ...

opt=$(tr '[:upper:]' '[:lower:]' <<<"$1" )
======================================
$1 - $9 - Это так называемые позиционные параметры, служат для передачи аргументов командной строки. 
Если аргументов больше 9, то они должны заключаться в фигурные скобки{} 
$0 - Имя скрипта который был запущен. 
$# - Количество аргументов командной строки или позиционных параметров
$? - Код с которым была завершена предыдущая команда. Если команда была выполнена удачно, 
то значение этой переменной будет 0, если же неудачно то не 0. 
$$ - Номер процесса под которым исполняется данный скрипт, очень удобно использовать 
в имени файла что бы сделать его уникальным. 
$! - Номер последнего, запущенного в фоне процесса. 
$- Список флагов переданных сценарию. Годиться разве что для проверки интерактивного режима.
$@ - То же самое что $*, только каждый параметр представлен отдельно.
Если есть вероятность, что ваши параметры будут содержать внутри себя пробелы, вы захотите использовать эту форму. 
$_	- Специальная переменная, содержит последний аргумент предыдущей команды.
$* - Данный параметр содержит в себе все параметры переданные из командной строки. 
начинающиеся с параметра 1. Если подстановка сделана внутри двойных кавычек, подставляется одно слово с первым знаком разделителя полей из специальной переменной IFS (interfield separator), разделяющим параметры, или без разделительного пробела, если IFS отсутствует. По умолчанию значение IFS -- пробел, табуляция и перевод строки. Если IFS не определен, разделитель использует пробел, поскольку он является умолчанием для IFS. 
 $PPID
======================================
echo -e   # ключ -e в комманде echo включает отображение "backslash escapes"; например \n - переход на следующую строку, \t -табуляция
echo -n   # ключ -n в команде echo сигнализирует, что после вывода информации не нужно переходить на следующую строку.

echo -e "\n" - перенос строки
echo -ne
Для того, что бы экранированные спец символы работали, вам необходимо запускать команду echo с параметром -e
\n перевод строки (новая строка)
\r перевод каретки
\t табуляция
\v вертикальная табуляция
\b забой (backspace)
\a "звонок" (сигнал)
\0xx ASCII-символ с кодом <em>0xx</em> в восьмеричном виде)
======================================
# обьявляем x, y, z как integer
declare -i x=10
declare -i y=10

типа Constant
declare -r var  
declare -r varName=value

ключи инструкций declare/typeset

-r readonly (только для чтения)
    declare -r var1
    (declare -r var1 аналогично объявлению readonly var1)

-i integer
    declare -i number
    # Сценарий интерпретирует переменную "number" как целое число.

-a array
    declare -a indices
    Переменная indices объявляется массивом.

-f functions
    declare -f
    Инструкция declare -f, без аргументов, приводит к выводу списка ранее объявленных функций в сценарии.
    declare -f function_name
    Инструкция declare -f function_name выводит имя функции function_name, если она была объявлена ранее.

-x export
    declare -x var3
    Эта инструкция объявляет переменную, как доступную для экспорта.
var=$value
    declare -x var3=373
    Инструкция declare допускает совмещение объявления и присваивания значения переменной одновременно.

VAR="A B   C         D"
echo $VAR
На выходе получим:
A B C D
То есть команда echo вывела 4 отдельных элемента. Для того, что бы наша переменная выводилась как один элемент, необходимо использовать кавычки:
echo "$VAR"
На выходе получим:
A B   C         D

Формат арифметического выражения выглядит так:
$((ВЫРАЖЕНИЕ)) или $[ВЫРАЖЕНИЯ]
z=$(($z+3))
let n+=1
let "var *= 4" значение переменной var будет увеличено в 4 раза.
/=    "слэш-равно" (уменьшение значения переменной в заданное число раз)
%=   "процент-равно" (найти остаток от деления значения переменной на заданное число, результат записать в переменную)

y=`expr $y + 1`
(( a = 23 ))  # Присвоение переменной в стиле C, с обоих строн от "=" стоят пробелы.
echo "a (начальное значение) = $a"

(( a++ ))     # Пост-инкремент 'a', в стиле C.
echo "a (после a++) = $a"
(( a-- ))     # Пост-декремент 'a', в стиле C.
echo "a (после a--) = $a"
(( ++a ))     # Пред-инкремент 'a', в стиле C.
echo "a (после ++a) = $a"
(( --a ))     # Пред-декремент 'a', в стиле C.
#while (( a <= LIMIT )) 
======================================
Список операторов:
      Operator                                                                                         Meaning
VAR++ and VAR--                                                         переменная пост-инкремент и пост-декремент
++VAR and --VAR                                                         переменная преинкремента и предекремента
- and +                                                                       унарные минус и плюс
! and ~                                                                       логические и побитового отрицание
**                                                                                  возведение в степень
*, / and %                                                                    умножение, деление, остаток
+ and -                                                                       сложения, вычитания
<< and >>                                                                     левый и правый побитовый сдвиг
<=, >=, < and >                                                         операторы сравнения
== and !=                                                                     равенство и неравенство
&                                                                                     побитовое И
^                                                                                   побитовое исключающее ИЛИ
|                                                                                   побитовое ИЛИ
&&                                                                                логическое И
||                                                                                  логическое ИЛИ
expr ? expr : expr                                                            условная оценка
=, *=, /=, %=, +=, -=, <<=, >>=, &=, ^= and |=                назначение
,                                                                                   разделитель между выражениями
:    пустая команда. [двоеточие] Это эквивалент операции "NOP" (no op, нет операции). Может рассматриваться как синоним встроенной команды true. Команда ":" так же является встроенной командой Bash, которая всегда возвращает "true" (0).
    : ${username=`whoami`}
    : ${HOSTNAME?} ${USER?} ${MAIL?}
======================================
Конструкция [[ ]] более универсальна, по сравнению с [ ]. Этот расширенный вариант команды test перекочевал в Bash из ksh88.
if [[ $condition1 && $condition2 ]]
Внутри этой конструкции не производится никакой дополнительной интерпретации имен файлов и не производится разбиение аргументов на отдельные слова, но допускается подстановка параметров и команд.

file=/etc/passwd

if [[ -e $file ]]
then
  echo "Файл паролей найден."
fi

Конструкция [[ ... ]] более предпочтительна, нежели [ ... ], поскольку поможет избежать некоторых логических ошибок. Например, операторы &&, ||, < и > внутри [[ ]] вполне допустимы, в то время как внутри [ ] порождают сообщения об ошибках.
Строго говоря, после оператора if, ни команда test, ни квадратные скобки ( [ ] или [[ ]] ) не являются обязательными.
Инструкция "if COMMAND" возвращает код возврата команды COMMAND.
несколько слов по поводу использования двойных и одинарных квадратных скобок. При использовании двойных скобок ваши переменный не будут разбиты на несколько отдельных слов если вы использовали пробел, как пример, переменная VAR="var with space" будет единым целым.

LATTER="ч"
read -p "Введите предложение : " STR
if [[ "$STR" == *$LATTER* ]]; 
then
      echo "$LATTER найдено."

[ — является специальной встроенной командой test воспринимающей свои аргументы как выражение сравнения или файловую проверку [.....].
(( — является арифметическими выражениями, которое так же возвращают код 0. Тем самым такие выражения могут участвовать в операциях сравнения.

if cmp a b &> /dev/null  # Подавление вывода.
then echo "Файлы a и b идентичны."
else echo "Файлы a и b имеют различия."
fi

If...then...else...fi синтаксис:
if [ условие ]
then
 если условие справедливо
 выполнить все команды до else или
 до fi
else
 если условие не справедливо
 выполнить все команды до fi
fi

if [ Условие 1 ]; then
   Команда 1
   Команда 2
elif [ Условие 2 ]; then
   Команда 3
   Команда 4
else
   Команда 5
fi

======================================
[ -a FILE ] Правда елси FILE существует.
[ -b FILE ] Правда елси FILE существует и это специальный блоковый файл.
[ -c FILE ] Правда елси FILE существует и это специальный знаковый файл.
[ -d FILE ] Правда елси FILE существует и это директория.
[ -e FILE ] Правда елси FILE существует.
[ -f FILE ] Правда елси FILE существует и это регулярный файл.
[ -g FILE ] Правда елси FILE существует и установлен SGID бит.
[ -h FILE ] Правда елси FILE существует и это символический ссылка.
[ -k FILE ] Правда елси FILE существует и второй промежуточный бит округления установлен.
[ -p FILE ] Правда елси FILE существует и это named pipe (FIFO).
[ -r FILE ] Правда елси FILE существует и он доступен на чтение.
[ -s FILE ] Правда елси FILE существует и больше нуля.
[ -u FILE ] Правда елси FILE существует и SUID (set user ID) бит установлен.
[ -w FILE ] Правда елси FILE существует и он доступен на запись.
[ -x FILE ] Правда елси FILE существует и он доступен на исполнение.
[ -O FILE ] Правда елси FILE существует принадлежит существующему пользователю
[ -G FILE ] Правда елси FILE существует принадлежит существующей группе.
[ -L FILE ] Правда елси FILE существует и это символический ссылка.
[ -N FILE ] Правда елси FILE существует и был изменен с тех пор как был прочитан.
[ -S FILE ] Правда елси FILE существует и это сокет.

[ FILE1 -nt FILE2 ] Правда, если файл FILE1 изменялся чаще чем FILE2, или есои FILE1 существует, а FILE2 нет.
[ FILE1 -ot FILE2 ] Правда, если файл FILE1 старше чем FILE2, или FILE1 существует, а FILE2 нет.
[ FILE1 -ef FILE2 ] Правда, если FILE1 и FILE2 относятся к одному устройству и номеру инода.

[ -o OPTIONNAME ] Правда если shell опция "OPTIONNAME" включена.
[ -z STRING ] Правда если длинна "STRING" равна 0.
[ -n STRING ] or [ STRING ] Правда если длинна "STRING" не равна 0.
[ STRING1 == STRING2 ] Правда если выражения эквивалентны. 
[ STRING1 != STRING2 ] Правда если выражения не эквивалентны.
[ STRING1 < STRING2 ] Правда если "STRING1" лексикографически упорядоченно до "STRING2".
[ STRING1 > STRING2 ] Правда если "STRING1" лексикографически упорядоченно после "STRING2".
[ ARG1 OP ARG2 ] "OP" это один из следующих параметров -eq, -ne, -lt, -le, -gt or -ge. Эти бинарные арифметические 
операторы возвращают результат "правда" если "ARG1" эквивалентен(-eq), не эквивалентен(-ne), меньше чем(-lt), 
Запомните, оператор = используется для сравнения строковых переменных, а -eq -- для сравнения целых чисел.
меньше или эквивалентен(-le), больше чем(-gt), больше или эквивалентно(-ge) к "ARG2".  
[ ! EXPR ] правда если выражение EXPR не справедливо.
[ ( EXPR ) ] возвращает значение EXPR. Это может быть использовано для изменения приоритета операторов.
[ EXPR1 -a EXPR2 ] правда, если оба выражения EXPR1 и EXPR2 справедливы.
[ EXPR1 -o EXPR2 ] правда, если хотя бы одно выражение EXPR1 или EXPR2 справедливы.
======================================
Logical AND &&
First_command &&Second_command
command2 is executed if, and only if, command1 returns an exit status of zero (true). In other words, run command1
and if it is successfull, then run command2.

Logical OR ||
First_command || Second_command
command2 is executed if, and only if, command1 returns a non-zero exit status. In other words, run command1
successfully or run command2.

Logical Not !
! expression OR [ ! expression ] OR if test ! condition

[5 !=10 ] && echo "Yes" || echo "No"
======================================
# Чтение строк из файла /etc/fstab.
#read -r LINE
{
read line1
read line2
} < $File

-a ANAME   Слова присваиваются подряд идущим элементам массива ANAME, присваивание начинается с элемента с индексом 0. Перед присваиванием все элементы удаляются из ANAME. Другие аргументы NAME игнорируются

-d DELIM   В качестве завершающего элемента входной строки используется символ DELIM, а не символ новой строки.

-e     Для чтения строки используется программа readline.

-n NCHARS    Команда read возвращает управление после чтения символов NCHARS и не ждет завершения ввода строки.

-p PROMPT         Перед попыткой прочитать какие-нибудь входные данные, сначала выдается PROMPT, который не завершается символом перевода строки. Эта строка приглашения отображается только тогда, когда входные данные поступают из терминала.

-r          Если задан этот параметр, то обратный слеш не используется для отмены свойств специальных символов. Обратный слеш считается частью строки. В частности, пару "обратный слэш и символ новой строки" нельзя будет использовать для указания продолжения строки.

-s        Тихий режим. Если входные данные поступают из терминала, на терминал не выдается эхо-ответ.

-t TIMEOUT              Если в течение TIMEOUT секунд не будет завершено чтение входной строки, то для команды read возникнет состояние таймаута и будет возвращен код неудачного выполнения команды. Этот параметр не действует, если команда read читает входные данные не из терминала и не из конвейера.

-u FD      Чтение входных данных из дескиптора файла FD.
You can use the  read command  to read data from the keyboard or file. You can pass the -u option to the  read
command from file descriptor instead of the keyboard. This is useful to read file line by line or one word at a time.
exec 3</etc/resolv.conf
read-u 3 a b
echo $a $b
exec 3<&-

read -p "Are you sure? " -n 1 -r
echo    # (optional) move to a new line
if [[ ! $REPLY =~ ^[Yy]$ ]]
then
    exit 1
fi

кроме как через read (stdin уже занят другим)
while read -r LINE; do
  echo HEH, got line "$LINE"
done < some_file

cat $FILE | while read line; do echo $line; done

cat ... | grep "..." | (while read p1 p2; do echo "${p1%/*/*}";done)

echo -n "дите значения для переменных 'var2' и 'var3' (через пробел или табуляцию): "
read var2 var3

Если команде read не была передано ни одной переменной, то ввод будет осуществлен в переменную $REPLY.
$REPLY    переменная по-умолчанию, куда записывается ввод пользователя, выполненный с помощью команды read если явно не задана другая переменная. Так же может использоваться в операторе select, для построения меню выбора.
echo -n "Ваше любимое растение? "
read
echo "Ваше любимое растение: $REPLY."

Ограничение времени ожидания команды read
TIMELIMIT=4        # 4 секунды
read -t $TIMELIMIT variable <&1

# Чтение данных, не дожидаясь нажатия на клавишу ENTER.

read -s -n1 -p "Нажмите клавишу " keypress
echo; echo "Была нажата клавиша "\"$keypress\""."
# -s   -- подавляет эхо-вывод, т.е. ввод с клавиатуры не отображается на экране.
# -n N -- ввод завершается автоматически, сразу же после ввода N-го символа.
# -p   -- задает вид строки подсказки - приглашения к вводу (prompt).
# Использование этих ключей немного осложняется тем, что они должны следовать в определенном порядке.

IFS=', ' read -a array <<< "$string"
======================================
The $word (a shell variable) is expanded and supplied to the command on its standard input. The following wc command will count words from given argument:
wc -w <<< "This is a test."

grep "nor" <<<$var >/dev/null && echo "Found" || echo "Not found"
Notice you can use shell pipes to grep into $var:
echo $var | grep -q "nor"  && echo "Found" || echo "Not found"
======================================
for arg in [list]
do
 команда(ы)...
done
#for arg in [list]; do команда(ы)...; done

Оператор while проверяет условие перед началом каждой итерации и если условие истинно (если код возврата равен 0), то управление передается в тело цикла. В отличие от циклов for, циклы while используются в тех случаях, когда количество итераций заранее не известно.
    while [condition]
        do
             command...
        done
Как и в случае с циклами for/in, при размещении ключевого слова do в одной строке с объявлением цикла, необходимо вставлять символ ";" перед do.
while [condition] ; do

while  [ 1 ]; do
    if [ "$1" = "x" ]; then y
    .....
shift
done


Оператор цикла until проверяет условие в начале каждой итерации, но в отличие от while итерация возможна только в том случае, если условие ложно.
until [condition-is-true]
do
 command...
done

break    выход из цикла for, while или until
continue выполнение следующей итерации цикла for, while или until
export   отмечает аргументы как переменные для передачи в дочерние процессы в среде
hash     запоминает полные имена путей команд, указанных в качестве аргументов, чтобы не искать их при следующем обращении
return   заставляет функцию оболочки выйти с указанным значением
shift    перемещает позиционные параметры налево
unset    вызывает уничтожение переменных оболочки
wait     ждет выхода из дочернего процесса и сообщает выходное состояние.
===================================
Полезно при написании скриптов на bash, которые конвертят и/или переносят файлы.
Имеется полное имя файла. Как извлечь разные его компоненты (отдельно путь, имя с раширением, имя без расширения, отдельно расширение)

foo=/tmp/my.dir/filename.tar.gz

path = ${foo%/*}    path=/tmp/my.dir
file = ${foo##*/}   file=filename.tar.gz
base = ${file%%.*}  base=filename
ext = ${file#*.}    ext=tar.gz

echo "Порядок использования: ${0##*/} <filename>"; exit 65;;  # Параметры командной строки отсутствуют, или первый параметр -- "пустой".

${var#Pattern}, ${var##Pattern}
    Удаляет из переменной $var наименьшую/наибольшую подстроку, совпадающую с шаблоном $Pattern. Поиск ведется с начала строки $var.

${var%Pattern}, ${var%%Pattern}
    Удаляет из переменной $var наименьшую/наибольшую подстроку, совпадающую с шаблоном $Pattern. Поиск ведется с конца строки $var.
======================================
Подстановку результатов выполнения команды $(cat file) можно заменить эквивалентной, но более быстрой: $(< file). 
======================================
Форматы команды printf
Вообще говоря, синтаксис команды printf взят от функции printf() языка программирования Си (и еще дюжины других). Но далеко не все знакомы с Си, поэтому мы внимательно рассмотрим все тонкости синтаксиса этой команды.

ФОРМАТ пишется в командной строке непосредственно после самой команды и заключается в кавычки - двойные или одинарные. Собственно говоря, кавычки нужны не всегда, но лучше их ставить, во избежание недоразумений. Это полезная привычка. (А ведь большинство привычек - вредные).

%b Рассматривает аргумент как строку, при этом интерпретирует все управляющие символы, содержащиеся в ней.
%s Рассматривает аргумент как просто как строку.
%c Рассматривает аргумент как символ, при этом берется первый символ выражения или строки.
%q Преобразует строку к виду, пригодному к использованию в качестве ввода в шелл. 
%d Представляет аргумент в виде десятичного числа, могущего иметь знак (+ или -). 
%u Представляет аргумент в виде десятичного числа, не имеющего знака.
%i То же, что и предыдущее.
%o Представляет аргумент в виде не имеющего знака восьмеричного числа. 
%x Представляет аргумент в виде не имеющего знака шестнадцатеричного числа. Буквы пишутся в нижнем регистре.
%X Представляет аргумент в виде не имеющего знака шестнадцатеричного числа, при этом буквы пишутся в верхнем регистре.
%f Интерпретирует аргумент как число с плавающей запятой.
%e Интерпретирует аргумент с удвоенной точностью (double precision), при этом выводит его в формате <N>+/-e<N>.
%E То же, что и предыдущее, только с заглавной буквой Е. 
%#o Восьмеричные числа пишутся с нулем впереди, если они сами не нулевые:
$ printf '%#0o\n' '177'
%#x, %#X Шестнадцатеричные числа пишутся с 0х или 0Х впереди, если они сами не нулевые:
$ printf '%#x\n' '177'
%a	Interprets the associated argument as double, and prints it in the form of a C99


Представление аргумента
N Нормальное десятичное число. Например 177
0N Восьмеричное число. Например 024.
0xN и 0XN Шестнадцатеричные числа. Например 0?41.
"А (обычные кавычки перед любой буквой) Интерпретируется как кодовый номер этой буквы в текущей кодировке. С кириллицей не работает.
'А (одинарные кавычки перед любой буквой) Интерпретируется как кодовый номер этой буквы в текущей кодировке. С кириллицей не работает.


$ printf '%q\n' 'Ваш,'
$'\320\222\320\260\321\210,'
$ printf '%b\n' $'\320\222\320\260\321\210,'
$ echo -e $'\320\222\320\260\321\210,'

Управляющие символы языка Си, работающие с командой printf
\" Двойные кавычки
\NNN Символ с восьмеричным значением NNN (от 1 до 3 цифр)
\\ Обратный слэш (\)
\a Звуковой сигнал
\b Забой
\c Не производить дальнейшую обработку данных
\f Перевод страницы
\n Новая строка
\r Возврат каретки
\v Вертикальная табуляция
\xHH Символ с шестнадцатеричным кодом HH (1 или 2 цифры)
\uHHHH Символ Unicode (ISO/IEC 10646) с шестнадцатеричным кодом HHHH (4 цифры)
\UHHHHHHHH Символ Unicode с шестнадцатеричным кодом HHHHHHHH (8 цифр)
%% Символ % 


======================================
echo "Удалить ПОВТОРЫ ПОВТОРЫ из текста" | sed 's@\(повторы\) \1 @\1 @i'
Результат: Удалить повторы из текста

цветной вывод
$tput setaf 3;cat temp;tput setaf default 
($tput setaf 3;cat temp;tput setaf 9 )
======================================
Convert pattern to lowercase
You can convert a pattern to lowercase using the tr command and here strings as follows:
echo "TeSt"| tr '[:upper:]' '[:lower:]'
var="TesT"
tr '[:upper:]' '[:lower:]' <<<"$var"

opt=$(tr '[:upper:]' '[:lower:]' <<<"$1" )

Now, run tr command as follows to convert all lowercase names to the uppercase, enter:
tr "[a-z]" "[A-Z]" <fnames.txt

tr "A-Z" "*" <filename  заменяет все символы верхнего регистра в filename на звездочки

Ключ -d удаляет символы из заданного диапазона.
echo "abcdef"                 # abcdef
echo "abcdef" | tr -d b-d     # aef
$ echo "my username is 432234" | tr -d [:digit:]

Ключ --squeeze-repeats (-s) удалит все повторяющиеся последовательности символов. Может использоваться для удаления лишних пробельных символов.

Ключ -c "complement" заменит символы в соответствии с шаблоном. Этот ключ воздействует только на те символы, которые НЕ соответствуют заданному шаблону.

======================================
Извлечение подстроки
${string:position}
    Извлекает подстроку из $string, начиная с позиции $position.
    Если строка $string -- "*" или "@", то извлекается позиционный параметр (аргумент), [1] с номером $position.
${string:position:length}
    Извлекает $length символов из $string, начиная с позиции $position.

    stringZ=abcABC123ABCabc
    #       0123456789.....
    #       Индексация начинается с 0.
    echo ${stringZ:7}                            # 23ABCabc
    echo ${stringZ:7:3}                          # 23A     # Извлекает 3 символа.
# Возможна ли индексация с "правой" стороны строки?
echo ${stringZ:(-4)}                         # Cabc
echo ${stringZ: -4} 
Если $string -- "*" или "@", то извлекается до $length позиционных параметров (аргументов), начиная с $position.
echo ${*:2}          # Вывод 2-го и последующих аргументов.
echo ${@:2}          # То же самое.
echo ${*:2:3}        # Вывод 3-х аргументов, начиная со 2-го.

expr substr $string $position $length
    Извлекает $length символов из $string, начиная с позиции $position.
    stringZ=abcABC123ABCabc
    #       123456789......
    #       Индексация начинается с 1.
    echo `expr substr $stringZ 1 2`              # ab
    echo `expr substr $stringZ 4 3`              # ABC


expr match "$string" '\($substring\)'
    Находит и извлекает первое совпадение $substring в $string, где $substring -- это регулярное выражение.

expr "$string" : '\($substring\)'
    Находит и извлекает первое совпадение $substring в $string, где $substring -- это регулярное выражение
echo `expr "$stringZ" : '\(.[b-c]*[A-Z]..[0-9]\)'`       # abcABC1
echo `expr "$stringZ" : '\(.......\)'`                   # abcABC1

expr match "$string" '.*\($substring\)'
expr "$string" : '.*\($substring\)'
    Находит и извлекает первое совпадение $substring в $string, где $substring -- это регулярное выражение. Поиск начинается с конца $string.

expr index $string $substring
    Номер позиции первого совпадения в $string c первым символом в $substring.
echo `expr index "$stringZ" 1c`              # 3

${string##substring}
    Удаление самой длинной, из найденных, подстроки $substring в строке $string. Поиск ведется с начала строки

${string%substring}
    Удаление самой короткой, из найденных, подстроки $substring в строке $string. Поиск ведется с конца строки

${string%%substring}
    Удаление самой длинной, из найденных, подстроки $substring в строке $string. Поиск ведется с конца строки

${string//substring/replacement}
    Замещает все вхождения $substring строкой $replacement.
    stringZ=abcABC123ABCabc
    echo ${stringZ/abc/xyz}           # xyzABC123ABCabc
                                      # Замена первой подстроки 'abc' строкой 'xyz'.

${string/#substring/replacement}
    Подстановка строки $replacement вместо $substring. Поиск ведется с начала строки $string.

${string/%substring/replacement}
    Подстановка строки $replacement вместо $substring. Поиск ведется с конца строки $string.
    stringZ=abcABC123ABCabc
    echo ${stringZ/#abc/XYZ}          # XYZABC123ABCabc
                                      # Поиск ведется с начала строки
======================================
Применим утилиту xargs — она принимает стандартный ввод и вызывает указанную программу с параметрами из стандартного ввода. Итак:

$  find ./ -type 'f' | grep -v 2 | xargs -n 1 -I % cp --parents  "%"  /path/to/dest/dir/

-n 1 значит, что только одна строка из стандартного ввода подставляется в комманду, а -I % — определяет символ, который будет заменен в целевой комманде на строчку из стандартного ввода. В нашем случае это будет

 cp --parents  "./dir1/file7.txt"  /path/to/dest/dir/
 cp --parents  "./file1.bin"  /path/to/dest/dir/

Еще одна полезная опция -- -0, в комбинации с find -print0 или grep -lZ позволяет обрабатывать аргументы, содержащие пробелы и кавычки.
find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f
find . -type d -mtime -0 -print0 | xargs -0 mv -t /path/to/target-dir
======================================
${parameter-default}, ${parameter:-default}
    Если параметр отсутствует, то используется значение по-умолчанию.
    echo ${username-`whoami`}
    # Вывод результата работы команды `whoami`, если переменная $username не установлена.
Формы записи ${parameter-default} и ${parameter:-default} в большинстве случаев можно считать эквивалентными. Дополнительный символ : имеет значение только тогда, когда parameter определен, но имеет "пустое" (null) значение.

${parameter=default}, ${parameter:=default}
    Если значения параметров не задананы явно, то они принимают значения по-умолчанию.
    Оба метода задания значений по-умолчанию до определенной степени идентичны. Символ : имеет значение только когда $parameter был инициализирован "пустым" (null) значением, [1] как показано выше.
    echo ${username=`whoami`}
    # Переменная "username" принимает значение, возвращаемое командой `whoami`.

${parameter?err_msg}, ${parameter:?err_msg}
    Если parameter инициализирован, то используется его значение, в противном случае -- выводится err_msg.
    Обе формы записи можно, до определенной степени, считать идентичными. Символ : имеет значение только когда parameter инициализирован "пустым" значением, см. ниже.
: ${1?"Порядок использования: $0 ARGUMENT"}
#  Сценарий завершит свою работу здесь, если входные аргументы отсутствуют,
#+ со следующим сообщением.

======================================
${var:pos}
    Подстанавливается значение переменной var, начиная с позиции pos.

${var:pos:len}
    Подстанавливается значение переменной var, начиная с позиции pos, не более len символов. См. Пример A-16.

${var/Pattern/Replacement}
    Первое совпадение с шаблоном Pattern, в переменной var замещается подстрокой Replacement.
    Если подстрока Replacement отсутствует, то найденное совпадение будет удалено.

${var//Pattern/Replacement}
    Глобальная замена. Все найденные совпадения с шаблоном Pattern, в переменной var, будут замещены подстрокой Replacement.
    Как и в первом случае, если подстрока Replacement отсутствует, то все найденные совпадения будут удалены.

    t=${var1#*-*}
    echo "var1 (все, от начала строки по первый символ \"-\", включительно, удаляется) = $t"
#  t=${var1#*-}  то же самое,
#+ поскольку оператор # ищет кратчайшее совпадение,
#+ а * соответствует любым предшествующим символам, включая пустую строку.
# (Спасибо S. C. за разъяснения.)
    t=${var1##*-*}
    echo "Если var1 содержит \"-\", то возвращается пустая строка...   var1 = $t"
    t=${var1%*-*}
    echo "var1 (все, начиная с последнего \"-\" удаляется) = $t"
    echo
# -------------------------------------------
    path_name=/home/bozo/ideas/thoughts.for.today
# -------------------------------------------
    echo "path_name = $path_name"
    t=${path_name##/*/}
    echo "Из path_name удален путь к файлу = $t"
#  В данном случае, тот эе эффект можно получить так:  t=`basename $path_name`
#  t=${path_name%/}; t=${t##*/}   более общее решение,
#+ но имеет некоторые ограничения.
#  Если $path_name заканчивается символом перевода строки, то `basename $path_name` не будет работать,
#+ но для данного случая вполне применимо.
# (Спасибо S.C.)
    t=${path_name%/*.*}
# Тот же эффект дает    t=`dirname $path_name`
    echo "Из path_name удалено имя файла = $t"
# Этот вариант будет терпеть неудачу в случаях: "../", "/foo////", # "foo/", "/".
#  Удаление имени файла, особенно когда его нет,
#+ использование dirname имеет свои особенности.
# (Спасибо S.C.)
    echo
    t=${path_name:11}
    echo "Из $path_name удалены первые 11 символов = $t"
    t=${path_name:11:5}
    echo "Из $path_name удалены первые 11 символов, выводится 5 символов = $t"
    echo
    t=${path_name/bozo/clown}
    echo "В $path_name подстрока \"bozo\" заменена на \"clown\" = $t"
    t=${path_name/today/}
    echo "В $path_name подстрока \"today\" удалена = $t"
    t=${path_name//o/O}
    echo "В $path_name все символы \"o\" переведены в верхний регистр, = $t"
    t=${path_name//o/}
    echo "Из $path_name удалены все символы \"o\" = $t"
    exit 0

TMP=${LINE#*\"*} удалить до первого вхождения в начале "


${var/#Pattern/Replacement}
    Если в переменной var найдено совпадение с Pattern, причем совпадающая подстрока расположена в начале строки (префикс), то оно заменяется на Replacement. Поиск ведется с начала строки

${var/%Pattern/Replacement}
    Если в переменной var найдено совпадение с Pattern, причем совпадающая подстрока расположена в конце строки (суффикс), то оно заменяется на Replacement. Поиск ведется с конца строки

Замена подстроки

Первое вхождение
	${string/substring/replacement}

Все вхождения
	${string//substring/replacement}

Удаление части строки

До первого с начала
	${string#substring}

До последнего с начала
	${string##substring}

До первого с конца
	${string%substring}

До последнего с конца
	${string%%substring}
======================================
определение длины переменной
len=${#line}

For an array, ${#array[*]} and ${#array[@]} give the number of elements in the array. 

stringZ=abcABC123ABCabc
echo `expr match "$stringZ" 'abc[A-Z]*.2'`   # 8
echo `expr "$stringZ" : 'abc[A-Z]*.2'`       # 8

echo `expr length $stringZ`      # 15
echo `expr "$stringZ" : '.*'`    # 15

======================================
Hack 88. Read data file fields inside a shell script 
 This example shows how to read a particular field from a data-file and 
manipulate it inside a shell-script. For example, let us assume the 
employees.txt file is in the format of {employee-name}:{employee-
id}:{department-name}, with colon delimited file as shown below. 
 
$ cat employees.txt 
Emma Thomas:100:Marketing 
Alex Jason:200:Sales 
Madison Randy:300:Product Development 
Sanjay Gupta:400:Support 
Nisha Singh:500:Sales 
 
The following shell script explains how to read specific fields from this 
employee.txt file. 
 $ vi read-employees.sh 
#!/bin/bash 
IFS=: 
echo "Employee Names:" 
echo "---------------" 
while read name empid dept 
do 
  echo "$name is part of $dept department" 
done < ~/employees.txt 
 
Assign execute privilege to the shell script and execute it. 
 $ chmod u+x read-employees.sh 
 $ ./read-employees.sh  

Employee Names: 
--------------- 
Emma Thomas is part of Marketing department 
Alex Jason is part of Sales department 
Madison Randy is part of Product Development department 
Sanjay Gupta is part of Support department 
Nisha Singh is part of Sales department
======================================


======================================
# Косвенные ссылки на переменные.
a=letter_of_alphabet
letter_of_alphabet=z
echo
# Прямое обращение к переменной.
echo "a = $a"
# Косвенное обращение к переменной.
eval a=\$$a
#eval a='$'$a
echo "А теперь a = $a"
======================================
!/bin/bash
PS3='Выберите ваш любимый овощ: ' # строка приглашения к вводу (prompt)
echo
select vegetable in "бобы" "морковь" "картофель" "лук" "брюква"
do
  echo
  echo "Вы предпочитаете $vegetable."
  echo ";-))"
  echo
  break  # если 'break' убрать, то получится бесконечный цикл.
done
exit 0
++++++++++++++++++++++++++++++++
PS3='Please enter your choice: '
options=("Option 1" "Option 2" "Option 3" "Quit")
select opt in "${options[@]}"
do
    case $opt in
        "Option 1")
            echo "you chose choice 1"
            ;;
        "Option 2")
            echo "you chose choice 2"
            ;;
        "Option 3")
            echo "you chose choice 3"
            ;;
        "Quit")
            break
            ;;
        *) echo invalid option;;
    esac
done

echo "Do you wish to install this program?"
select yn in "Yes" "No"
case $yn in
    Yes ) make install;;
    No ) exit;;
esac
++++++++++++++++++++++++++++++++++++
select FILENAME in *;
do
  case $FILENAME in
        "$QUIT")
          echo "Exiting."
          break
          ;;
        *)
          echo "You picked $FILENAME ($REPLY)"
          chmod go-rwx "$FILENAME"
          ;;
  esac
done
# список выбора [in list] отсутствует, поэтому 'select' использует входные аргументы функции.
Если в операторе select список in list не задан, то в качестве списка будет использоваться список аргументов ($@), передаваемый сценарию или функции.
======================================
можно проверять слова в переменной

OIFS=$IFS
IFS=" ";

stringarray=($stringtest);
for ((i=0; i<${#stringarray[@]}; ++i)); do
    echo "part $i: ${stringarray[$i]}"
done
IFS=$OIFS
    

======================================

======================================

======================================

======================================

======================================
sh -n scriptname -- проверит наличие синтаксических ошибок, не запуская сам сценарий. Того же эффекта можно добиться, вставив в сценарий команду set -n или set -o noexec. Обратите внимание, некоторые из синтаксических ошибок не могут быть выявлены таким способом.

sh -v scriptname -- выводит каждую команду прежде, чем она будет выполнена. Того же эффекта можно добиться, вставив в сценарий команду set -v или set -o verbose.

Ключи -n и -v могут употребляться совместно: sh -nv scriptname.

sh -x scriptname -- выводит, в краткой форме, результат исполнения каждой команды. Того же эффекта можно добиться, вставив в сценарий команду set -x или set -o xtrace.
Вставив в сценарий set -u или set -o nounset, вы будете получать сообщение об ошибке unbound variable всякий раз, когда будет производиться попытка обращения к необъявленной переменной.

отключить действие той или иной опции, следует вставить конструкцию set +o option-name, или set +option-abbrev.     

-C 	noclobber 	Предотвращает перезапись файла в операциях перенаправления вывода (не распространяется на конвейеры (каналы) -- >|)
-D 	(нет) 	Выводит список строк в двойных кавычках, которым предшествует символ $, сам сценарий не исполняется
-a 	allexport 	Экспорт всех, определенных в сценарии, переменных
-b 	notify 	Выводит уведомление по завершении фоновой задачи (job) (довольно редко используется в сценариях)
-c ... 	(нет) 	Читает команды из ...
-f 	noglob 	Подстановка имен файлов (globbing) запрещена
-i 	interactive 	Сценарий запускается в интерактивном режиме
-p 	privileged 	Сценарий запускается как "suid" (осторожно!)
-r 	restricted 	Сценарий запускается в ограниченном режиме (см. Глава 20).
-u 	nounset 	При попытке обращения к неопределенным переменным, выдает сообщение об ошибке и прерывает работу сценария
-v 	verbose 	Выводит на stdout каждую команду прежде, чем она будет исполнена
-x 	xtrace 	Подобна -v, но выполняет подстановку команд
-e 	errexit 	Прерывает работу сценария при появлении первой же ошибки (когда команда возвращает ненулевой код завершения)
-n 	noexec 	Читает команды из сценария, но не исполняет их (проверка синтаксиса)
-s 	stdin 	Читает команды с устройства stdin
-t 	(нет) 	Выход после исполнения первой команды
- 	(нет) 	Конец списка ключей (опций), последующие аргументы будут восприниматься как позиционные параметры.

======================================
И-список
    command-1 && command-2 && command-3 && ... command-n
    Каждая последующая команда, в таком списке, выполняется только тогда, когда предыдущая команда вернула код завершения true (ноль). Если какая-либо из команд возвращает false (не ноль), то исполнение списка команд в этом месте завершается, т.е. следующие далее команды не выполняются.


ИЛИ-список
    command-1 || command-2 || command-3 || ... command-n
    Каждая последующая команда, в таком списке, выполняется только тогда, когда предыдущая команда вернула код завершения false (не ноль). Если какая-либо из команд возвращает true (ноль), то исполнение списка команд в этом месте завершается, т.е. следующие далее команды не выполняются. Очевидно, что "ИЛИ-списки" имеют смысл обратный, по отношению к "И-спискам"

======================================
sort -k 9 <(ls -l /bin) <(ls -l /usr/bin) <(ls -l /usr/X11R6/bin)
# Список файлов в трех основных каталогах 'bin', отсортированный по именам файлов.
# Обратите внимание: на вход 'sort' поданы три самостоятельные команды.

tar cf >(bzip2 -c > file.tar.bz2) $directory_name
# Вызовет "tar cf /dev/fd/?? $directory_name" и затем "bzip2 -c > file.tar.bz2".

log()  # Запись даты и времени в файл.
{ echo "$(date)  $*" >>&7     # Добавляет в конец файла.
}
======================================
trap command signals

command — что именно необходимо выполнить при перехвате сигнала;
signals — список сигналов, которые необходимо перехватывать. Сигналы можно указывать как в полном виде — SIGTERM, так и в виде кода — 1, 2 и т.д.

trap 'echo "Exit"; exit 1' 2
trap 'echo "Exit"; exit 1' 1 2 3 15

Tрассировка переменной

trap 'echo "VARIABLE-TRACE> $LINENO: \$variable = \"$variable\""' DEBUG
# Выводить значение переменной после исполнения каждой команды.

SIGABRT-6-Завершение с дампом памяти-Сигнал посылаемый функцией abort() 	Управление
SIGALRM-14-Завершение-Сигнал истечения времени, заданного alarm() 	Уведомление
SIGBUS-10 -Завершение с дампом памяти-Неправильное обращение в физическую память 	Исключение
SIGCHLD-18-Игнорируется-Дочерний процесс завершен или остановлен 	Уведомление
SIGCONT-25-Продолжить выполнение 	Продолжить выполнение ранее остановленного процесса 	Управление
SIGFPE-8-Завершение с дампом памяти-Ошибочная арифметическая операция 	Исключение
SIGHUP-1-Завершение-Закрытие терминала 	Уведомление
SIGILL-4-Завершение с дампом памяти-Недопустимая инструкция процессора 	Исключение
SIGINT-2-Завершение -Сигнал прерывания (Ctrl-C) с терминала 	Управление
SIGKILL-9-завершение-Безусловное завершение 	управление
SIGPIPE-13-Завершение -Запись в разорванное соединение (пайп, сокет) 	Уведомление
SIGQUIT-3-Завершение с дампом памяти-Сигнал «Quit» с терминала (Ctrl-\) 	Управление
SIGSEGV-11-Завершение с дампом памяти 	Нарушение при обращении в память 	Исключение
SIGSTOP-23-остановка процесса 	Остановка выполнения процесса 	управление
SIGTERM-15-Завершение 	Сигнал завершения (сигнал по умолчанию для утилиты kill) 	Управление
SIGTSTP-20-Остановка процесса 	Сигнал остановки с терминала (Ctrl-Z). 	Управление
SIGTTIN-26-Остановка процесса 	Попытка чтения с терминала фоновым процессом 	Управление
SIGTTOU-27-Остановка процесса-Попытка записи на терминал фоновым процессом 	Управление
SIGUSR1-16-Завершение 	Пользовательский сигнал № 1 	Пользовательский
SIGUSR2-17-Завершение 	Пользовательский сигнал № 2 	Пользовательский
SIGPOLL-22 -Завершение 	Событие, отслеживаемое poll() 	Уведомление
SIGPROF-29-Завершение 	Истечение таймера профилирования 	Отладка
SIGSYS-12-Завершение с дампом памяти-Неправильный системный вызов 	Исключение
SIGTRAP-5 -Завершение с дампом памяти-Ловушка трассировки или брейкпоинт 	Отладка
SIGURG-21-Игнорируется-На сокете получены срочные данные-Уведомление
SIGVTALRM-28-Завершение-Истечение «виртуального таймера»-Уведомление
SIGXCPU-30-Завершение с дампом памяти-Процесс превысил лимит процессорного времени-Исключение
SIGXFSZ-31-Завершение с дампом памяти-Процесс превысил допустимый размер файла-Исключение

Конструкция trap '' SIGNAL (две одиночных кавычки) -- запрещает SIGNAL для оставшейся части сценария. Конструкция trap SIGNAL -- восстанавливает действие сигнала SIGNAL. Эти конструкции могут использоваться для защиты критических участков сценария от нежелательного прерывания.

       trap '' 2  # Сигнал 2 (Control-C) -- запрещен.
        command
        command
        command
        trap 2     # Разрешение реакции на Control-C
       
=======================================
tee
        Это опрератор перенаправления, но с некоторыми особенностями. Подобно водопроводным трубам, "tee" позволяет "направить поток" данных в несколько файлов и на stdout одновременно, никак не влияя на сами данные. Эта команда может оказаться очень полезной при отладке.
cat listfile* | sort | tee check.file | uniq > result.file

mkfifo
        Эта, редко встречающаяся, команда создает именованный канал - очередь, через который производится обмен данными между процессами. [3] Как правило, один процесс записывает данные в очередь (FIFO), а другой читает данные из очереди.tем не менее, он должен быть открытым в обоих состояниях одновременно, прежде чем Вы захотите провести в нем операции ввода или вывода. Однако, открытие FIFO для чтения обычно блокирует его до тех пор, пока другой процесс не откроет этот же FIFO для записи, и наоборот. 

общаться между процессами можно с помощью именных каналов pipe
#mkfifo tmppipe (mknod tmppipe)
cat ... > tmppipe (если в одном теримнале то надо &)
cat < tmppipe

mkfifo pipe
gzip -9 -c < pipe > out
Параллельно, в другом процессе можно выполнить:
cat file > pipe
что приведёт к сжатию передаваемых данных gzip-ом.
su xyz -c "ssh $THERE \"cat >/home/xyz/backup/${HERE}-daily.tar.gz\" < /pipe"&
cd /
tar -czf - bin boot dev etc home info lib man root sbin share usr var >/pipe

logger
    Добавляет в системный журнал (/var/log/messages) сообщение от пользователя. Для добавления сообщения пользователь не должен обладать привилегиями суперпользователя.
logger -t $0 -i Logging at line "$LINENO".
# Ключ "-t" задает тэг записи в журнале. logger[..] => tag [...]
# Ключ "-i" -- записывает ID процесса.

pidof  -   Возвращает идентификатор процесса (pid) по его имени. 

fuser  -   Возвращает идентификаторы процессов, использующих указанный файл(ы) или каталог. С ключом -k, завершает найденные процессы. Может с успехом использоваться для защиты системы, особенно в сценариях разграничения доступа к системным службам
======================================

======================================
date '+DATE: %m/%d/%y%nTIME: %H:%M:%S'
n	вставить символ перевода строки
t	вставить символ табуляции
m	месяц года - от 01 до 12
d	день месяца - от 01 до 31
y	2 цифры года - от 00 до 99
D	дата в виде мм/дд/гг
H	час - от 00 до 23
M	минуты - от 00 до 59
S	секунды - от 00 до 59
T	время в виде чч:мм:сс
j	день года - от 001 до 366
w	день недели - воскресенье = 0
a	сокращение дня недели - от Sun до Sat
h	сокращение названия месяца - от Jan до Dec
r	время по 12-часовой шкале

======================================
perl -ne 'print if (/^1/)' phonelist.txt
======================================
\0n 	n — восьмеричное число от 0 до 377 	 8-битная
\xdd 	d — шестнадцатеричная цифра            8-битная
\udddd 	d — шестнадцатеричная цифра 16-битная (Юникод)

\t 	Табуляция 	            HT 	Horizontal tabulation	 (ASCII code 9)
\v 	Вертикальная табуляция 	VT 	Vertical tabulation
\r 	Возврат каретки 	        CR 	Carriage return	 (ASCII code 13)
\n 	Перевод строки          	LF 	Line feed	 (ASCII code 10)
\f 	Конец страницы 	        FF 	Form feed  (ASCII code 12)
\a 	Звонок 	                       BEL 	Bell character	 (ASCII code 7)
\e 	Escape-символ            	ESC 	Escape character	 (ASCII code 27)
\b 	Забой               Должен находиться внутри квадратных скобок (иначе интерпретируется как граница слова).	BS 	Backspace
\cA … \cZ 	Ctrl+A … Ctrl+Z          Например, последовательность \cM\cJ соответствует управляющим символам CR LF.  Эквивалентно \x01 … \x1A.
		
\d 	[0-9] 	Цифра
\D 	[^\d] 	Любой символ, кроме цифры
\w 	[A-Za-zА-Яа-я0-9_] 	Символы, образующие «слово» (буквы, цифры и символ подчёркивания)[1]
\W 	[^\w] 	Символы, не образующие «слово»
\s 	[ \t\v\r\n\f] 	Пробельный символ
\S 	[^\s] 	Не пробельный символ

[:upper:] 	[A-Z] 	               Символы верхнего регистра
[:lower:] 	[a-z] 	                       Символы нижнего регистра
[:alpha:] 	[[:upper:][:lower:]] 	Буквы
[:digit:] 	[0-9], т. е. \d 	       Цифры
[:xdigit:] 	[[:digit:]A-Fa-f] 	        Шестнадцатеричные цифры
[:alnum:] 	[[:alpha:][:digit:]] 	Буквы и цифры
[:word:] 	[[:alnum:]_], т. е. \w 	Символы, образующие «слово»
[:punct:] 	[-!"#$%&'()*+,./:;<=>?@[\\\]_`{|}~] 	Знаки пунктуации
[:blank:] 	[ \t] 	                        Пробел и табуляция
[:space:] 	[[:blank:]\v\r\n\f], т. е. \s 	Пробельные символы
[:cntrl:] 	[\x00-\x1F\x7F] 	          Управляющие символы
[:graph:] 	[\x21-\x7E] 	          Печатные символы
[:print:] 	[\x20-\x7E], т. е. [[:graph:] ] 	Печатные символы с пробелом
======================================
grep
. (точка)	Точка соответствует любому символу исключая символ новой строки.
^ (крышка)	Пустая последовательность, возникающая в начале строки.
$ (знак доллара)	Пустая последовательность, возникающая в конце строки.
A	Буква A в верхнем регистре.
a	Буква a в нижнем регистре.
\d	Одиночная цифра.
\D	Одиночный символ, не являющийся цифрой.
\w	Любой одиночный цифро-буквенный символ, этот оператор - синоним [:alnum:]. [A-z0-9_]
[A-E]	Любая буква из A, B, C, D или E в верхнем регистре.
[^A-E]	Любой символ, кроме буквы из A, B, C, D или E в верхнем регистре.
X?	Одна или ни одной заглавной буквы X.
X*	Ноль или более заглавной буквы X.
X+	Одна или более заглавная буква X.
X{n}	Точно n заглавных букв X.
X{n,m}	Не менее n и не более m заглавных букв X. Если опустить m, то оператор означает "как минимум n заглавных букв X".
(abc|def)+	Не менее одной последовательности abc, def, abc и def будут считаться совпадением.
.* 	Обозначение любого количества любых символов между двумя частями регулярного выражения.

 \<...\>-- отмечают границы слова.Выражение "\<the\>" соответствует слову "the", и не соответствует словам "them", "there", "other" и т.п.
| -- выполняет роль логического оператора "ИЛИ" в регулярных выражениях и служит для задания набора альтернатив.
bash$ egrep 're(a|e)d' misc.txt

-E, --extended-regexp PATTERN - интерпретировать PATTERN как расширенное регулярное выражение
-o, --only-matching - выводит только то, что соответствует регулярному выражению



======================================
перебор файлов в каталоге

При необходимости перебрать все файлы в каком-либо каталоге и выполнить над ними какие-либо действия, можно воспользоваться простым однострочным циклом:

for file in /etc/config/*; do wc -l $file; stat -c %s $file; done

Можно использовать и find для рекурсивного поиска и дополнительных фильтров:

for file in `find /etc -type f -name "*.conf"`
do
   wc -l $file;
   stat -c %s $file;
done

Если выполняется не более одного действия над файлом, можно обойтись без цикла:

find /etc -type f | xargs wc -l

Если в именах файлов есть пробелы, то добавляем к find параметр -print0:

find /etc -type f -print0 | xargs -0 wc -l

find . -type d -mtime -0 -exec mv -t /path/to/target-dir {} +
======================================

======================================
echo "Список всех пользователей:"
OIFS=$IFS; IFS=:       # В файле /etc/passwd, в качестве разделителя полей
                       # используется символ ":" .
while read name passwd uid gid fullname ignore
do
  echo "$name ($fullname)"
done </etc/passwd      # перенаправление ввода.
IFS=$OIFS              # Восстановление предыдущего состояния переменной $IFS.
+++++++++++++++++++++++++++++++++++++++++
#  Если переменная $IFS устанавливается внутри цикла,
#+ то отпадает необходимость сохранения ее первоначального значения
#+ во временной переменной.
#  Спасибо Dim Segebart за разъяснения.
echo "------------------------------------------------"
echo "Список всех пользователей:"

while IFS=: read name passwd uid gid fullname ignore
do
  echo "$name ($fullname)"
done </etc/passwd   # перенаправление ввода.

echo
echo "Значение переменной \$IFS осталось прежним: $IFS"
======================================
# --------------------------------------------
# Коды клавиш.
arrowup='\[A'
arrowdown='\[B'
arrowrt='\[C'
arrowleft='\[D'
insert='\[2'
delete='\[3'
# --------------------------------------------
SUCCESS=0
OTHER=65
echo -n "Нажмите на клавишу...  "
# Может потребоваться нажать на ENTER, если была нажата клавиша
# не входящая в список выше.
read -n3 key                      # Прочитать 3 символа.

echo -n "$key" | grep "$arrowup"  #Определение нажатой клавиши.
if [ "$?" -eq $SUCCESS ]
then
  echo "Нажата клавиша \"."
  exit $SUCCESS
fi
======================================
getopts OPTSTRING VARNAME [ARGS...]

where:
OPTSTRING	tells getopts which options to expect and where to expect arguments (see below)
The option-string tells getopts which options to expect and which of them must have an argument. The syntax is very simple — every option character is simply named as is, this example-string would tell getopts to look for -f, -A and -x: 
If the very first character of the option-string is a : (colon), which normally would be nonsense because there's no option letter preceeding it, getopts switches to the mode "silent error reporting". In productive scripts, this is usually what you want (handle errors yourself and don't get disturbed by annoying messages). 
VARNAME	tells getopts which shell-variable to use for option reporting
ARGS	tells getopts to parse these optional words instead of the positional parameters

OPTIND	Holds the index to the next argument to be processed. This is how getopts "remembers" its own status between invocations. Also usefull to shift the positional parameters after processing with getopts. OPTIND is initially set to 1, and needs to be re-set to 1 if you want to parse anything again with getopts
OPTARG	This variable is set to any argument for an option found by getopts. It also contains the option flag of an unknown option.
OPTERR	(Values 0 or 1) Indicates if Bash should display error messages generated by the getopts builtin. The value is initialized to 1 on every shell startup - so be sure to always set it to 0 if you don't want to see annoying messages!

# Символ : после опции 'e' указывает на то, что с данной опцией может идти
# дополнительный аргумент.
   # Обратите внимание: с ключом 'е' должен передаваться дополнительный аргумент,
    # в противном случае отработает выбор "по-умолчанию".
#!/bin/bash
usage() { echo "Usage: $0 [-s <45|90>] [-p <string>]" 1>&2; exit 1; }
while getopts ":s:p:" o; do
    case "${o}" in
        s)
            s=${OPTARG}
            ((s == 45 || s == 90)) || usage
            ;;
        p)
            p=${OPTARG}
            ;;
        *)
            usage
            ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      ;;
    esac
done
shift $((OPTIND-1))
if [ -z "${s}" ] || [ -z "${p}" ]; then
    usage
fi
echo "s = ${s}"
echo "p = ${p}"
-----------------------------------------------------------
Example runs:

$ ./myscript.sh
Usage: ./myscript.sh [-s <45|90>] [-p <string>]

$ ./myscript.sh -h
Usage: ./myscript.sh [-s <45|90>] [-p <string>]

$ ./myscript.sh -s "" -p ""
Usage: ./myscript.sh [-s <45|90>] [-p <string>]

$ ./myscript.sh -s 10 -p foo
Usage: ./myscript.sh [-s <45|90>] [-p <string>]

$ ./myscript.sh -s 45 -p foo
s = 45
p = foo

$ ./myscript.sh -s 90 -p bar
s = 90
p = bar
======================================
Встроенные документы
cat <<End-of-message
-------------------------------------
Это первая строка сообщения.
Это вторая строка сообщения.
-------------------------------------
End-of-message

GetPersonalData ()
{
  read firstname
  read lastname
  read address
  read city
  read state
  read zipcode
} # Это немного напоминает интерактивную функцию, но... # Передать ввод в функцию.
GetPersonalData <<RECORD001
Bozo
Bozeman
2726 Nondescript Dr.
Baltimore
MD
21226
RECORD001



: << DEBUGXXX
#  Такая методика создания блочных комментариев
#+ может использоваться для комментирования блоков кода во время отладки.
#  Это экономит силы и время, т.к. не нужно втавлять символ "#" в начале каждой строки,
#+ а затем удалять их.
DEBUGXXX
======================================
Shell Variables           http://wiki.bash-hackers.org/syntax/shellvars

$BASH  содержится полный путь до исполняемого файла командной оболочки Bash.
$BASH_VERSION В переменную $BASH_VERSION записывается версия Bash.
$CDPATH хранит пути поиска каталога. (используется при вводе команды cd имя_каталога без слэша)
$CLASSPATH содержит список каталогов для поиска файлов классов Java и архивов Java.
$HOME домашний каталог текущего пользователя.
$HOSTNAME  хранится имя компьютера.
$HISTSIZE количество событий, хранимых в истории за 1 сеанс
$HISTFILE Расположение файла истории событий
$HISTFILESIZE количество событий, хранимых в истории между сеансами
$IFS переменная хранит символы, являющиеся разделителями команд и параметров. (по умолчанию - пробел, табуляция и новая строка)
$LANG текущая установка локализации, которая позволяет настроить командную оболочку для использования в различных странах и на различных языках.
$MAIL Место, где храниться почта
$OSTYPE В переменной $OSTYPE содержится описание операционной системы.
$PATH список каталогов для поиска команд и приложений, когда полный путь к файлу не задан.
$PS1 используется как основная строка приглашения. (то самое [root@proxy ~]#)
$PS2  используется как вторичная строка приглашения.
$PROMPT_COMMAND Эта команда должна быть выполнена до отображения строки приглашения Bash.
$PWD полный путь к текущему рабочему каталогу.
$SHELL полный путь к текущей командной оболочке.
$USER В переменной $USER содержится имя текущего пользователя.
$EUID  Expands to the effective user ID of the current user, initialized at shell startup.
:!: Do not rely on this variable when security is a concern

if [ "$UID" -ne "$ROOT_UID" ];then
  echo "Сценарий должен с привилегиями root.";  exit $E_NOTROOT;fi

$DIRSTACK - содержимое вершины стека каталогов
$EDITOR - текстовый редактор по умолчанию
$EUID - Эффективный UID. Если вы использовали программу su для выполнения команд от другого пользователя, то эта переменная содержит UID этого пользователя, в то время как...
$UID - ...содержит реальный идентификатор, который устанавливается только при логине.
$FUNCNAME - имя текущей функции в скрипте.
$GROUPS - массив групп к которым принадлежит текущий пользователь
$HOME - домашний каталог пользователя
$HOSTNAME - ваш hostname
$HOSTTYPE - архитектура машины.
$LC_CTYPE - внутренняя переменная, котороя определяет кодировку символов
$OLDPWD - прежний рабочий каталог
$OSTYPE - тип ОС
$PATH - путь поиска программ
$PPID - идентификатор родительского процесса
$SECONDS - время работы скрипта(в сек.)

==================================================
При открытии дополнительных файлов, дескрипторы с 3 по 9 остаются незанятыми.
&>filename      # Перенаправление stdout и stderr в файл "filename".
2>&1# Перенаправляется stderr на stdout.
        # Сообщения об ошибках передаются туда же, куда и стандартный вывод.

i>&j  # Перенаправляется файл с дескриптором i в j.
        # Вывод в файл с дескриптором i передается в файл с дескриптором j.

ls -yz >> command.log 2>&1
# Сообщение о неверной опции "yz" в команде "ls" будет записано в файл "command.log".
# Поскольку stderr перенаправлен в файл.

[j]<>filename
      # Файл "filename" открывается на чтение и запись, и связывается с дескриптором "j".
      # Если "filename" отсутствует, то он создается.
      # Если дескриптор "j" не указан, то, по-умолчанию, береtся дескриптор 0, stdin.
      #
      # Как одно из применений этого -- запись в конкретную позицию в файле.
          echo 1234567890 > File    # Записать строку в файл "File".
          exec 3<> File       # Открыть "File" и связать с дескриптором 3.
          read -n 4 <&3             # Прочитать 4 символа.
          echo -n . >&3             # Записать символ точки.
          exec 3>&-                 # Закрыть дескриптор 3.
          cat File                  # ==> 1234.67890
      # Произвольный доступ, да и только!


Закрытие дескрипторов файлов
n<&-    Закрыть дескриптор входного файла n.
0<&-, <&-    Закрыть stdin.
n>&-    Закрыть дескриптор выходного файла n.
1>&-, >&-    Закрыть stdout.

Дочерние процессы наследуют дескрипторы открытых файлов. По этой причине и работают конвейеры. Чтобы предотвратить наследование дескрипторов -- закройте их перед запуском дочернего процесса.
exec 3>&1                              # Сохранить текущее "состояние" stdout.
ls -l 2>&1 >&3 3>&- | grep bad 3>&-    # Закрыть дескр. 3 для 'grep' (но не для 'ls').
#              ^^^^   ^^^^
exec 3>&-                              # Теперь закрыть его для оставшейся части сценария.

конструкция exec >filename перенаправляет вывод на stdout в заданный файл. После этого, весь вывод от команд, который обычно направляется на stdout, теперь выводится в этот файл.
exec 6>&1           # Связать дескр. #6 со stdout.
                           # Сохраняя stdout.
exec > $LOGFILE     # stdout замещается файлом "logfile.txt".
.......
exec 1>&6 6>&-      # Восстановить stdout и закрыть дескр. #6.


Create a shell script called fdwrite.sh:
#!/bin/bash
# Let us assign the file descriptor to file for output
# fd # 3 is output file 
exec 3>/tmp/output.txt
# Executes echo commands and # Send output to 
# the file descriptor (fd) # 3 i.e. write output to /tmp/output.txt
echo "This is a test" >&3
# Write date command output to fd # 3
date >&3
# Close fd # 3
exec 3<&-
==================================================
Ctrl- ^
Meta - M
Основные сочетания

    ^c — Прервать текущий процесс (сигнал SIGINT)
    ^\ — Прервать текущий процесс с дампом памяти(core damp)
    ^d — Eof (выход из консольного пользовательского процесса)
    ^s — приостановить процесс (stop)
    ^q — Запустить процесс
    ^z — Перевести процесс в фоновый режим
    ^j — Сброс параметров терминала
    ^m — Аналог клавиши “Enter”
    ^r — Переводит в режим поиска команды по истории. Повторное нажатие перебирает сходные по маске строки
    ^l — Очистка экрана
    Tab — Автозавершение команд/вывести список команд, начинающихся на введенную
    ScrLock — Приостановка выполнения(печати) текущей команды
    Ctrl+Alt+Del — Закрыть систему и перегрузится
    !! - повторить последнюю команду
    q - часто используется для выхода из программ (quit)

Навигация

    Up; Down — Просмотр и редактирование истории команд
    Alt+Left — Переключение по терминалам влево(консоль)
    Alt+Right — Переключение по терминалам вправо(консоль)
    Ctrl+Alt+F# - переключение на терминал #
    Shift+PgUp — Прокрутка текста вверх
    Shift+PgDown — Прокрутка текста вниз
    ^b — Перемещение на символ назад (back)
    ^f — На символ вперёд
    M b — На слово назад (back)
    M f — На слово вперёд (forward)
    ^a — Переводит курсор в начало строки
    ^e — Переводит курсор в конец строки

Редактирование

    ^h —  "<-" тоже самое что и backspace
    ^d — Удаление символа в позиции курсора
    ^h — Удаление символа перед позицией курсора
    M d — вырезать в буфер символ до ближайшего справа пробела
    ^w —Вырезать в буфер символы до ближайшего слева пробела
    ^u — Вырезать в буфер строку ввода слева от курсора
    ^k — Вырезать (удалить - kill) в буфер строку ввода справа от курсора
    ^t — Смена положения соседних символов
    ^w — Вырезать в буфер слово слева от курсора
    M <- - Вырезать в буфер слово влево от курсора
    ^y — Вставка (yunk) из буфера в текущую позицию курсора
    M u - Символы в верхний регистр (Uppear)
    M l - Символы низкого регистра (Lower)
    M c - Символы в режиме капитализации (Capitalize)
    ^_ — Откат редактирования (Ctrl+Shift+-)


наверное, знаете, текстовые файлы DOS/Windows имеют в конце каждой строки символ CR (carriage return - возврат каретки) и LF (line feed - перевод строки), а текстовые файлы UNIX содержат только символ LF. 

==================================================
    /dev/tcp/host/port - If host is a valid hostname or Internet address, and port is an integer port number or service name, bash attempts to open a TCP connection to the corresponding socket.
    /dev/udp/host/port - If host is a valid hostname or Internet address, and port is an integer port number or service name, bash attempts to open a UDP connection to the corresponding socket.

You can use this technquie to dermine if port is open or closed on local or remote server without using nmap or other port scanner:
# find out if TCP port 25 open or not
(echo >/dev/tcp/localhost/25) &>/dev/null && echo "TCP port 25 open" || echo "TCP port 25 close"

Description: Ubuntu 9.10
echo >/dev/tcp/localhost/22 && echo "ssh open"
==================================================
LL=$(echo "# line1 $1 $2 #"|wc -c)
LL=$((LL - 1))
printf "%${LL}s\n" " " | tr " " "#"
echo "# line1 $1 $2 #"
printf "%${LL}s\n" " " | tr " " "#"

вначале идет вычисление длины выводимого сообщения, потом печать нужного количества #
-------------------------
$ for((i=0;i<array_size;i++));
do
    printf "%10s %10d %10s" stringarray[$i] numberarray[$i] anotherfieldarray[%i]
done

Notice I used %10s for strings. %s is the important part. It tells it to use a string. The 10 in the middle says how many columns it is to be. %d is for numerics (digits).
----------------------------
#/bin/bash
divider===============================
divider=$divider$divider

header="\n %-10s %8s %10s %11s\n"
format=" %-10s %08d %10s %11.2f\n"

width=43

printf "$header" "ITEM NAME" "ITEM ID" "COLOR" "PRICE"

printf "%$width.${width}s\n" "$divider"

printf "$format" \
Triangle 13  red 20 \
==================================================
==================================================
==================================================
==================================================
==================================================
mkfifo mypipe
cat mypipe | bar &
foo mypipe&
rm mypipe

Программа, которая пишет в именованный пайп, ведёт себя с ним как с файлом. Т.е. пишет себе и пишет. Программа, которая читает — аналогично. Читает себе и читает. Чтение идёт в том порядке, как была осуществлена запись (FIFO — first in first out). Положения относительно пайпа (слева/справа) определяются тем, кто читает, а кто пишет.
Важная же особенность пайпа — способность тормознуть читающую/пищущую программу, если буфер пуст/переполнен. 
Рассмотрим на примере чтения. Программа пишет в пайп одну строчку в секунду. Программа чтения читает с максимально возможной скоростью. Программа «вычитывает» всё, что было в буфере, и посылает следующий запрос. Ядро этот запрос задерживает до того момента, пока не появятся данные. Таким образом, можно не париться с синхронизацией — появятся данные, программа-обработчик получит управление обратно из read() и обработает очередную порцию данных.
==================================================
проверка каталога на наличие содержимого
$ find "/tmp" -type f -exec echo Found file {} \;
$ [ "$(ls -A /path/to/directory)" ] && echo "Not Empty" || echo "Empty"
$ [ "$(ls -A /tmp)" ] && echo "Not Empty" || echo "Empty"
[[ $(ls -A your/dir) ]] && echo "contains files" || echo "empty"
Note: ls returns $?=2 when the directory does not exist. But no difference between a file and an empty directory.
if [ -e /some/dir/* ]; then echo "huzzah"; fi;
if find /some/dir/ -maxdepth 0 -empty | read v; then echo "Empty dir"; fi
if [ `find your/dir -prune -empty -type d` ]; then
echo "empty directory"
else;  echo "contains files (or does not exist or is not a directory)";fi

=============================================
http://habrahabr.ru/post/126701/

#!/bin/bash

SETCOLOR_SUCCESS="echo -en \\033[1;32m"
SETCOLOR_FAILURE="echo -en \\033[1;31m"
SETCOLOR_NORMAL="echo -en \\033[0;39m"

echo -e "Удаляется файл..."

# Команда, которую нужно отследить
rm test_file

if [ $? -eq 0 ]; then
    $SETCOLOR_SUCCESS
    echo -n "$(tput hpa $(tput cols))$(tput cub 6)[OK]"
    $SETCOLOR_NORMAL
    echo
else
    $SETCOLOR_FAILURE
    echo -n "$(tput hpa $(tput cols))$(tput cub 6)[fail]"
    $SETCOLOR_NORMAL
    echo
fi

#!/bin/bash

red=$(tput setf 4)
green=$(tput setf 2)
reset=$(tput sgr0)
toend=$(tput hpa $(tput cols))$(tput cub 6)

echo -e "Удаляется файл..."

# Команда, которую нужно отследить
rm test_file

if [ $? -eq 0 ]; then
    echo -n "${green}${toend}[OK]"
else
    echo -n "${red}${toend}[fail]"
fi
echo -n "${reset}"
echo

--------------------------------------------------
x0: зобацал часы с кукушкой на серваке
x0: в cron.hourly пешу скрыпт

KUKU=`/bin/date +%I`
while [ $KUKU -gt 0 ]; do
eject /dev/cdrom
cat /root/xxx/kuku.au > /dev/dsp
eject -t /dev/cdrom
KUKU=$((KUKU-1))
done

x0: ночальнег в полдень зашел и окуел
x0: сцуко спасская биг тауэр
